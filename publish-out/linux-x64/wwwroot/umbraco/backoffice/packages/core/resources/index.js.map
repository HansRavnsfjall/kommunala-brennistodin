{"version":3,"file":"index.js","sources":["../../../../src/packages/core/resources/extractUmbNotificationColor.function.ts","../../../../src/packages/core/resources/isUmbNotifications.function.ts","../../../../src/packages/core/resources/apiTypeValidators.function.ts","../../../../src/packages/core/resources/api-interceptor.controller.ts","../../../../src/packages/core/resources/umb-error.ts","../../../../src/packages/core/resources/resource.controller.ts","../../../../src/packages/core/resources/try-execute/try-execute.controller.ts","../../../../src/packages/core/resources/try-execute/tryExecute.function.ts","../../../../src/packages/core/resources/try-execute/batch-try-execute.function.ts","../../../../src/packages/core/resources/try-execute/tryExecuteAndNotify.function.ts","../../../../src/packages/core/resources/cancelable-promise.ts","../../../../src/packages/core/resources/try-execute/tryXhrRequest.function.ts"],"sourcesContent":["import type { UmbNotificationColor } from '../notification/types.js';\r\nimport { EventMessageTypeModel } from '@umbraco-cms/backoffice/external/backend-api';\r\n\r\n/**\r\n * Extracts the UmbNotificationColor from the EventMessageTypeModel.\r\n * @param {EventMessageTypeModel} type The EventMessageTypeModel to extract the color from.\r\n * @returns {UmbNotificationColor} The corresponding UmbNotificationColor.\r\n * @example\r\n * const color = extractUmbNotificationColor(EventMessageTypeModel.ERROR); // color will be 'danger'\r\n */\r\nexport function extractUmbNotificationColor(type: EventMessageTypeModel): UmbNotificationColor {\r\n\tswitch (type) {\r\n\t\tcase EventMessageTypeModel.ERROR:\r\n\t\t\treturn 'danger';\r\n\t\tcase EventMessageTypeModel.WARNING:\r\n\t\t\treturn 'warning';\r\n\t\tcase EventMessageTypeModel.INFO:\r\n\t\tcase EventMessageTypeModel.DEFAULT:\r\n\t\t\treturn 'default';\r\n\t\tcase EventMessageTypeModel.SUCCESS:\r\n\t\t\treturn 'positive';\r\n\t\tdefault:\r\n\t\t\treturn '';\r\n\t}\r\n}\r\n","import { EventMessageTypeModel } from '@umbraco-cms/backoffice/external/backend-api';\r\n\r\n/**\r\n *\r\n * @param notification\r\n */\r\nfunction objectIsUmbNotification(notification: unknown): notification is UmbNotificationsEventModel {\r\n\tif (typeof notification !== 'object' || notification === null) {\r\n\t\treturn false;\r\n\t}\r\n\tconst object = notification as UmbNotificationsEventModel;\r\n\treturn (\r\n\t\ttypeof object.category === 'string' &&\r\n\t\ttypeof object.message === 'string' &&\r\n\t\ttypeof object.type === 'string' &&\r\n\t\tObject.values(EventMessageTypeModel).includes(object.type)\r\n\t);\r\n}\r\n\r\nexport interface UmbNotificationsEventModel {\r\n\tcategory: string;\r\n\tmessage: string;\r\n\ttype: EventMessageTypeModel;\r\n}\r\n\r\n/**\r\n *\r\n * @param notifications\r\n */\r\nexport function isUmbNotifications(notifications: Array<unknown>): notifications is Array<UmbNotificationsEventModel> {\r\n\treturn notifications.every(objectIsUmbNotification);\r\n}\r\n\r\nexport const UMB_NOTIFICATION_HEADER = 'umb-notifications';\r\n","import type { UmbProblemDetails } from './types.js';\r\n\r\n/**\r\n * Checks if the given error is an instance of ApiError.\r\n * @param {*} error The error to check\r\n * @returns {boolean} True if the error is an instance of ApiError, false otherwise\r\n * @deprecated Use {UmbApiError.isUmbApiError} instead and map your object to {UmbApiError} if needed.\r\n */\r\nexport function isApiError(error: unknown): error is { body?: string; status?: number; request?: unknown } {\r\n\treturn typeof error === 'object' && error !== null && 'body' in error && 'status' in error && 'request' in error;\r\n}\r\n\r\n/**\r\n * Checks if the given error is an instance of CancelError.\r\n * @param {*} error The error to check\r\n * @returns {boolean} True if the error is an instance of CancelError, false otherwise\r\n * @deprecated Use {UmbApiCancelError.isUmbApiCancelError}` instead and map your object to {UmbApiCancelError} if needed.\r\n */\r\nexport function isCancelError(error: unknown): error is Error {\r\n\treturn error instanceof Error && (error.name === 'CancelError' || (error as Error).message === 'Request aborted');\r\n}\r\n\r\n/**\r\n * Checks if the given promise is cancelable, i.e. if it has a cancel method.\r\n * @param {*} promise The promise to check\r\n * @returns {boolean} True if the promise is cancelable, false otherwise\r\n */\r\nexport function isCancelablePromise<T>(promise: unknown): promise is Promise<T> & { cancel: () => void } {\r\n\treturn typeof (promise as Promise<T> & { cancel: () => void }).cancel === 'function';\r\n}\r\n\r\n/**\r\n * Checks if the given error is an instance of ProblemDetails.\r\n * @param {*} error The error to check\r\n * @returns {boolean} True if the error is an instance of ProblemDetails, false otherwise\r\n */\r\nexport function isProblemDetailsLike(error: unknown): error is UmbProblemDetails {\r\n\treturn (\r\n\t\ttypeof error === 'object' &&\r\n\t\terror !== null &&\r\n\t\t'type' in error &&\r\n\t\t'title' in error &&\r\n\t\t'status' in error &&\r\n\t\t(typeof (error as { detail?: unknown }).detail === 'undefined' ||\r\n\t\t\ttypeof (error as { detail?: unknown }).detail === 'string') &&\r\n\t\t(typeof (error as { instance?: unknown }).instance === 'undefined' ||\r\n\t\t\ttypeof (error as { instance?: unknown }).instance === 'string') &&\r\n\t\t(typeof (error as { operationStatus?: unknown }).operationStatus === 'undefined' ||\r\n\t\t\ttypeof (error as { operationStatus?: unknown }).operationStatus === 'string') &&\r\n\t\t(typeof (error as { errors?: unknown }).errors === 'undefined' ||\r\n\t\t\ttypeof (error as { errors?: unknown }).errors === 'object')\r\n\t);\r\n}\r\n","import { extractUmbNotificationColor } from './extractUmbNotificationColor.function.js';\r\nimport { isUmbNotifications, UMB_NOTIFICATION_HEADER } from './isUmbNotifications.function.js';\r\nimport { isProblemDetailsLike } from './apiTypeValidators.function.js';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\r\nimport type { UmbNotificationColor } from '@umbraco-cms/backoffice/notification';\r\nimport type { umbHttpClient } from '@umbraco-cms/backoffice/http-client';\r\n\r\nexport class UmbApiInterceptorController extends UmbControllerBase {\r\n\t/**\r\n\t * Binds the default interceptors to the client.\r\n\t * This includes the auth response interceptor, the error interceptor and the umb-notifications interceptor.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t */\r\n\tpublic bindDefaultInterceptors(client: typeof umbHttpClient) {\r\n\t\tthis.addAuthResponseInterceptor(client);\r\n\t\tthis.addUmbGeneratedResourceInterceptor(client);\r\n\t\tthis.addUmbNotificationsInterceptor(client);\r\n\t\tthis.addForbiddenResponseInterceptor(client);\r\n\t\tthis.addErrorInterceptor(client);\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for 401 errors and lets the UmbAuthContext know the user is timed out.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddAuthResponseInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use(async (response: Response) => {\r\n\t\t\tif (response.status === 401) {\r\n\t\t\t\t// See if we can get the UmbAuthContext and let it know the user is timed out\r\n\t\t\t\tconst authContext = await this.getContext(UMB_AUTH_CONTEXT, { preventTimeout: true });\r\n\t\t\t\tif (!authContext) {\r\n\t\t\t\t\tthrow new Error('Could not get the auth context');\r\n\t\t\t\t}\r\n\t\t\t\tauthContext.timeOut();\r\n\t\t\t}\r\n\t\t\treturn response;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for 403 errors and displays them as a notification.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddForbiddenResponseInterceptor(client: typeof umbHttpClient) {\r\n\t\t\tclient.interceptors.response.use(async (response: Response) => {\r\n\t\t\t\tif (response.status === 403) {\r\n\t\t\t\t\tconst headline = 'Permission Denied';\r\n\t\t\t\t\tconst message = 'You do not have the necessary permissions to complete the requested action. If you believe this is in error, please reach out to your administrator.';\r\n\r\n\t\t\t\t\tthis.#peekError(headline, message, null);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn response;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for the Umb-Generated-Resource header and replaces the value into the response body.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddUmbGeneratedResourceInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use(async (response: Response) => {\r\n\t\t\tif (!response.headers.has('Umb-Generated-Resource')) {\r\n\t\t\t\treturn response;\r\n\t\t\t}\r\n\r\n\t\t\tconst generatedResource = response.headers.get('Umb-Generated-Resource');\r\n\t\t\tif (generatedResource === null) {\r\n\t\t\t\treturn response;\r\n\t\t\t}\r\n\r\n\t\t\t// Generate new response body with the generated resource, which is a guid\r\n\t\t\tconst newResponse = new Response(generatedResource, {\r\n\t\t\t\t...response,\r\n\t\t\t});\r\n\r\n\t\t\treturn newResponse;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for 500 errors and displays them as a notification if any.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddErrorInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use(async (response) => {\r\n\t\t\tif (response.ok) return response;\r\n\r\n\t\t\t// Handle 500 errors - we need to show a notification\r\n\t\t\tif (response.status === 500) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// Clones the response to read the body\r\n\t\t\t\t\tconst origResponse = response.clone();\r\n\t\t\t\t\tconst error = await origResponse.json();\r\n\r\n\t\t\t\t\t// If there is no JSON in the error, we just return the response\r\n\t\t\t\t\tif (!error) return response;\r\n\r\n\t\t\t\t\t// Check if the error is a problem details object\r\n\t\t\t\t\tif (!isProblemDetailsLike(error)) {\r\n\t\t\t\t\t\t// If not, we just return the response\r\n\t\t\t\t\t\treturn response;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet headline = error.title ?? 'Server Error';\r\n\t\t\t\t\tlet message = 'A fatal server error occurred. If this continues, please reach out to your administrator.';\r\n\r\n\t\t\t\t\t// Special handling for ObjectCacheAppCache corruption errors, which we are investigating\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\terror.detail?.includes('ObjectCacheAppCache') ||\r\n\t\t\t\t\t\terror.detail?.includes('Umbraco.Cms.Infrastructure.Scoping.Scope.DisposeLastScope()')\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\theadline = 'Please restart the server';\r\n\t\t\t\t\t\tmessage =\r\n\t\t\t\t\t\t\t'The Umbraco object cache is corrupt, but your action may still have been executed. Please restart the server to reset the cache. This is a work in progress.';\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.#peekError(headline, message, error.errors);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t// Ignore JSON parse error\r\n\t\t\t\t\tconsole.error('[Interceptor] Caught a 500 Error, but failed parsing error body (expected JSON)', e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Return original response\r\n\t\t\treturn response;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for the umb-notifications header and displays them as a notification if any. Removes the umb-notifications from the headers.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddUmbNotificationsInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use((response) => {\r\n\t\t\t// Check if the response has the umb-notifications header\r\n\t\t\t// If not, we just return the response\r\n\t\t\tconst umbNotifications = response.headers.get(UMB_NOTIFICATION_HEADER);\r\n\t\t\tif (!umbNotifications) return response;\r\n\r\n\t\t\t// Parse the notifications from the header\r\n\t\t\t// If the header is not a valid JSON, we just return the response\r\n\t\t\ttry {\r\n\t\t\t\tconst notifications = JSON.parse(umbNotifications);\r\n\t\t\t\tif (!isUmbNotifications(notifications)) return response;\r\n\r\n\t\t\t\tfor (const notification of notifications) {\r\n\t\t\t\t\tthis.#peekError(\r\n\t\t\t\t\t\tnotification.category,\r\n\t\t\t\t\t\tnotification.message,\r\n\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\textractUmbNotificationColor(notification.type),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t} catch {\r\n\t\t\t\t// Ignore JSON parse errors\r\n\t\t\t}\r\n\r\n\t\t\treturn response;\r\n\t\t});\r\n\t}\r\n\r\n\tasync #peekError(headline: string, message: string, details: unknown, color?: UmbNotificationColor) {\r\n\t\t// Store the host for usage in the following async context\r\n\t\tconst host = this._host;\r\n\r\n\t\t// This late importing is done to avoid circular reference [NL]\r\n\t\t(await import('@umbraco-cms/backoffice/notification')).umbPeekError(host, {\r\n\t\t\theadline,\r\n\t\t\tmessage,\r\n\t\t\tdetails,\r\n\t\t\tcolor,\r\n\t\t});\r\n\t}\r\n}\r\n","import type { UmbProblemDetails } from './types.js';\r\n\r\nexport class UmbError extends Error {\r\n\tpublic override name = 'UmbError';\r\n\r\n\tpublic static isUmbError(error: unknown): error is UmbError {\r\n\t\treturn error instanceof UmbError || (error as UmbError).name === 'UmbError';\r\n\t}\r\n}\r\n\r\nexport class UmbCancelError extends UmbError {\r\n\tpublic override name = 'UmbCancelError';\r\n\r\n\tpublic static isUmbCancelError(error: unknown): error is UmbCancelError {\r\n\t\treturn error instanceof UmbCancelError || (error as UmbCancelError).name === 'UmbCancelError';\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms a CancelError into an UmbCancelError.\r\n\t * @param {*} error The CancelError to transform.\r\n\t * @returns {UmbCancelError} The transformed UmbCancelError.\r\n\t * @deprecated Use `UmbCancelError.isUmbCancelError` instead and map your object to `UmbCancelError` if needed.\r\n\t */\r\n\tpublic static fromLegacyCancelError(error: Error): UmbCancelError {\r\n\t\treturn new UmbCancelError(error.message);\r\n\t}\r\n}\r\n\r\n/**\r\n * UmbApiError is a class that extends UmbError and represents an error that occurs during an API call.\r\n */\r\nexport class UmbApiError extends UmbError {\r\n\tpublic override name = 'UmbApiError';\r\n\tpublic status: number;\r\n\tpublic request: unknown;\r\n\tpublic problemDetails: UmbProblemDetails;\r\n\r\n\tpublic constructor(message: string, status: number, request: unknown, problemDetails: UmbProblemDetails) {\r\n\t\tsuper(message);\r\n\t\tthis.status = status;\r\n\t\tthis.request = request;\r\n\t\tthis.problemDetails = problemDetails;\r\n\t}\r\n\r\n\tpublic static isUmbApiError(error: unknown): error is UmbApiError {\r\n\t\treturn error instanceof UmbApiError || (error as UmbApiError).name === 'UmbApiError';\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms an ApiError into an UmbApiError.\r\n\t * @param {*} error The ApiError to transform.\r\n\t * @returns {UmbApiError} The transformed UmbApiError.\r\n\t * @deprecated Use `UmbCancelError.isUmbApiError` instead and map your object to `UmbApiError` if needed.\r\n\t */\r\n\tpublic static fromLegacyApiError(error: Error & { body?: string; status?: number; request?: unknown }): UmbApiError {\r\n\t\t// ApiError - body could hold a ProblemDetails from the server\r\n\t\tlet problemDetails: UmbProblemDetails | null = null;\r\n\t\tif (typeof error.body !== 'undefined' && !!error.body) {\r\n\t\t\ttry {\r\n\t\t\t\tproblemDetails = typeof error.body === 'string' ? JSON.parse(error.body) : error.body;\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.error('Error parsing error body (expected JSON)', e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new UmbApiError(\r\n\t\t\terror.message,\r\n\t\t\terror.status ?? 0,\r\n\t\t\terror.request,\r\n\t\t\tproblemDetails ?? { title: error.message, type: 'ApiError', status: error.status ?? 0 },\r\n\t\t);\r\n\t}\r\n}\r\n","import { isApiError, isCancelablePromise, isCancelError, isProblemDetailsLike } from './apiTypeValidators.function.js';\r\nimport { UmbApiError, UmbCancelError, UmbError } from './umb-error.js';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\nexport class UmbResourceController<T = unknown> extends UmbControllerBase {\r\n\t/**\r\n\t * The promise that is being executed.\r\n\t * @protected\r\n\t */\r\n\tprotected _promise;\r\n\r\n\tconstructor(host: UmbControllerHost, promise: PromiseLike<T>, alias?: string) {\r\n\t\tsuper(host, alias);\r\n\r\n\t\tthis._promise = promise;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps any error to an UmbError.\r\n\t * @internal\r\n\t * @param {*} error The error to map\r\n\t * @returns {*} The mapped error\r\n\t */\r\n\tmapToUmbError(error: unknown): UmbApiError | UmbCancelError | UmbError {\r\n\t\tif (isProblemDetailsLike(error)) {\r\n\t\t\treturn new UmbApiError(error.detail ?? error.title, error.status, null, error);\r\n\t\t} else if (isApiError(error)) {\r\n\t\t\treturn UmbApiError.fromLegacyApiError(error as never);\r\n\t\t} else if (isCancelError(error)) {\r\n\t\t\treturn UmbCancelError.fromLegacyCancelError(error);\r\n\t\t} else if (UmbCancelError.isUmbCancelError(error)) {\r\n\t\t\treturn error;\r\n\t\t} else if (UmbApiError.isUmbApiError(error)) {\r\n\t\t\treturn error;\r\n\t\t} else if (UmbError.isUmbError(error)) {\r\n\t\t\treturn error;\r\n\t\t}\r\n\t\t// If the error is not an UmbError, we will just return it as is\r\n\t\treturn new UmbError(error instanceof Error ? error.message : 'Unknown error');\r\n\t}\r\n\r\n\t/**\r\n\t * Cancel all resources that are currently being executed by this controller if they are cancelable.\r\n\t *\r\n\t * This works by checking if the promise is a CancelablePromise and if so, it will call the cancel method.\r\n\t *\r\n\t * This is useful when the controller is being disconnected from the DOM.\r\n\t * @see CancelablePromise\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n\t */\r\n\tcancel(): void {\r\n\t\tif (isCancelablePromise(this._promise)) {\r\n\t\t\tthis._promise.cancel();\r\n\t\t}\r\n\t}\r\n\r\n\toverride hostDisconnected(): void {\r\n\t\tsuper.hostDisconnected();\r\n\t\tthis.cancel();\r\n\t}\r\n\r\n\toverride destroy(): void {\r\n\t\tsuper.destroy();\r\n\t\tthis.cancel();\r\n\t}\r\n\r\n\tprotected async _peekError(headline: string, message: string, details: unknown) {\r\n\t\t// Store the host for usage in the following async context\r\n\t\tconst host = this._host;\r\n\r\n\t\t// This late importing is done to avoid circular reference\r\n\t\t(await import('@umbraco-cms/backoffice/notification')).umbPeekError(host, {\r\n\t\t\theadline,\r\n\t\t\tmessage,\r\n\t\t\tdetails,\r\n\t\t});\r\n\t}\r\n}\r\n","import { isProblemDetailsLike } from '../apiTypeValidators.function.js';\r\nimport { UmbResourceController } from '../resource.controller.js';\r\nimport type { UmbApiResponse, UmbTryExecuteOptions } from '../types.js';\r\nimport { UmbApiError, UmbCancelError } from '../umb-error.js';\r\n\r\nexport class UmbTryExecuteController<T> extends UmbResourceController<T> {\r\n\t#abortSignal?: AbortSignal;\r\n\r\n\tasync tryExecute(opts?: UmbTryExecuteOptions): Promise<UmbApiResponse<T>> {\r\n\t\ttry {\r\n\t\t\tif (opts?.abortSignal) {\r\n\t\t\t\tthis.#abortSignal = opts.abortSignal;\r\n\t\t\t\tthis.#abortSignal.addEventListener('abort', () => this.cancel(), { once: true });\r\n\t\t\t}\r\n\r\n\t\t\treturn (await this._promise) as UmbApiResponse<T>;\r\n\t\t} catch (error) {\r\n\t\t\t// Error might be a legacy error, so we need to check if it is an UmbError\r\n\t\t\tconst umbError = this.mapToUmbError(error);\r\n\r\n\t\t\tif (!opts?.disableNotifications) {\r\n\t\t\t\tthis.#notifyOnError(umbError);\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\terror: umbError,\r\n\t\t\t} as UmbApiResponse<T>;\r\n\t\t}\r\n\t}\r\n\r\n\toverride destroy(): void {\r\n\t\tif (this.#abortSignal) {\r\n\t\t\tthis.#abortSignal.removeEventListener('abort', this.cancel);\r\n\t\t}\r\n\t\tsuper.destroy();\r\n\t}\r\n\r\n\t#notifyOnError(error: unknown) {\r\n\t\tif (UmbCancelError.isUmbCancelError(error)) {\r\n\t\t\t// Cancel error, do not show notification\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet headline = 'An error occurred';\r\n\t\tlet message = 'An error occurred while trying to execute the request.';\r\n\t\tlet details: Record<string, string[]> | undefined = undefined;\r\n\r\n\t\t// Check if we can extract problem details from the error\r\n\t\tconst problemDetails = UmbApiError.isUmbApiError(error)\r\n\t\t\t? error.problemDetails\r\n\t\t\t: isProblemDetailsLike(error)\r\n\t\t\t\t? error\r\n\t\t\t\t: undefined;\r\n\r\n\t\tif (problemDetails) {\r\n\t\t\t// UmbProblemDetails, show notification\r\n\t\t\tmessage = problemDetails.title;\r\n\t\t\tdetails = problemDetails.errors ?? undefined;\r\n\t\t} else {\r\n\t\t\t// Unknown error, show notification\r\n\t\t\theadline = '';\r\n\t\t\tmessage = error instanceof Error ? error.message : 'An unknown error occurred.';\r\n\t\t}\r\n\r\n\t\tthis._peekError(headline, message, details);\r\n\t}\r\n}\r\n","import type { UmbApiResponse, UmbTryExecuteOptions } from '../types.js';\r\nimport { UmbTryExecuteController } from './try-execute.controller.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\n/**\r\n * Make a request and handle errors.\r\n * @param {UmbControllerHost} host The host to use for the request and where notifications will be shown.\r\n * @param {Promise<T>} promise The promise to execute.\r\n * @param {UmbTryExecuteOptions} opts Options for the request.\r\n * @returns {Promise<UmbApiResponse<T>>} A promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n * @example\r\n * const { data, error } = await tryExecute(this, myPromise, {\r\n *   abortSignal: myAbortSignal,\r\n *   disableNotifications: false,\r\n * });\r\n * if (!error) {\r\n *\t console.log('Success:', data);\r\n * }\r\n */\r\nexport async function tryExecute<T>(\r\n\thost: UmbControllerHost,\r\n\tpromise: Promise<T>,\r\n\topts?: UmbTryExecuteOptions,\r\n): Promise<UmbApiResponse<T>> {\r\n\tconst controller = new UmbTryExecuteController(host, promise);\r\n\tconst response = await controller.tryExecute(opts);\r\n\tcontroller.destroy();\r\n\treturn response;\r\n}\r\n","import { tryExecute } from './tryExecute.function.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\n/**\r\n * Batches promises and returns a promise that resolves to an array of results\r\n * @param {UmbControllerHost} host - The host to use for the request and where notifications will be shown\r\n * @param {Array<Array<BatchEntryType>>} chunks - The array of chunks to process\r\n * @param {(chunk: Array<BatchEntryType>) => Promise<PromiseResult>} callback - The function to call for each chunk\r\n * @returns {Promise<PromiseSettledResult<PromiseResult>[]>} - A promise that resolves to an array of results\r\n */\r\nexport function batchTryExecute<BatchEntryType, PromiseResult>(\r\n\thost: UmbControllerHost,\r\n\tchunks: Array<Array<BatchEntryType>>,\r\n\tcallback: (chunk: Array<BatchEntryType>) => Promise<PromiseResult>,\r\n): Promise<PromiseSettledResult<PromiseResult>[]> {\r\n\treturn Promise.allSettled(chunks.map((chunk) => tryExecute(host, callback(chunk), { disableNotifications: true })));\r\n}\r\n","import type { UmbApiResponse } from '../types.js';\r\nimport { UmbTryExecuteController } from './try-execute.controller.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { UmbDeprecation } from '@umbraco-cms/backoffice/utils';\r\n\r\n/**\r\n * Make a request and notify the user of any errors.\r\n * This function is a wrapper around the {@link tryExecute} function and will notify the user of any errors.\r\n * It is useful for making requests where you want to handle errors in a consistent way.\r\n * @param {UmbControllerHost} host The host to use for the request.\r\n * @param {Promise<T>} resource The resource to request.\r\n * @returns {Promise<UmbApiResponse<T>>} A promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n * @deprecated Use the {@link tryExecute} function instead and handle the error in the caller.\r\n * This function is kept for backwards compatibility and will be removed in a future version.\r\n */\r\nexport async function tryExecuteAndNotify<T>(\r\n\thost: UmbControllerHost,\r\n\tresource: Promise<T>,\r\n): Promise<UmbApiResponse<T>> {\r\n\tnew UmbDeprecation({\r\n\t\tdeprecated: 'The tryExecuteAndNotify function is deprecated.',\r\n\t\tremoveInVersion: '18.0.0',\r\n\t\tsolution: 'Use the tryExecute function with options instead.',\r\n\t}).warn();\r\n\tconst controller = new UmbTryExecuteController(host, resource);\r\n\tconst response = await controller.tryExecute({ disableNotifications: false });\r\n\tcontroller.destroy();\r\n\treturn response;\r\n}\r\n","import { UmbCancelError } from './umb-error.js';\r\n\r\nexport interface OnCancel {\r\n\treadonly isResolved: boolean;\r\n\treadonly isRejected: boolean;\r\n\treadonly isCancelled: boolean;\r\n\r\n\t(cancelHandler: () => void): void;\r\n}\r\n\r\nexport class UmbCancelablePromise<T> implements Promise<T> {\r\n\tprivate _isResolved: boolean;\r\n\tprivate _isRejected: boolean;\r\n\tprivate _isCancelled: boolean;\r\n\treadonly cancelHandlers: (() => void)[];\r\n\treadonly promise: Promise<T>;\r\n\tprivate _resolve?: (value: T | PromiseLike<T>) => void;\r\n\tprivate _reject?: (reason?: unknown) => void;\r\n\r\n\tconstructor(\r\n\t\texecutor: (\r\n\t\t\tresolve: (value: T | PromiseLike<T>) => void,\r\n\t\t\treject: (reason?: unknown) => void,\r\n\t\t\tonCancel: OnCancel,\r\n\t\t) => void,\r\n\t) {\r\n\t\tthis._isResolved = false;\r\n\t\tthis._isRejected = false;\r\n\t\tthis._isCancelled = false;\r\n\t\tthis.cancelHandlers = [];\r\n\t\tthis.promise = new Promise<T>((resolve, reject) => {\r\n\t\t\tthis._resolve = resolve;\r\n\t\t\tthis._reject = reject;\r\n\r\n\t\t\tconst onResolve = (value: T | PromiseLike<T>): void => {\r\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._isResolved = true;\r\n\t\t\t\tif (this._resolve) this._resolve(value);\r\n\t\t\t};\r\n\r\n\t\t\tconst onReject = (reason?: unknown): void => {\r\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._isRejected = true;\r\n\t\t\t\tif (this._reject) this._reject(reason);\r\n\t\t\t};\r\n\r\n\t\t\tconst onCancel = (cancelHandler: () => void): void => {\r\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis.cancelHandlers.push(cancelHandler);\r\n\t\t\t};\r\n\r\n\t\t\tObject.defineProperty(onCancel, 'isResolved', {\r\n\t\t\t\tget: (): boolean => this._isResolved,\r\n\t\t\t});\r\n\r\n\t\t\tObject.defineProperty(onCancel, 'isRejected', {\r\n\t\t\t\tget: (): boolean => this._isRejected,\r\n\t\t\t});\r\n\r\n\t\t\tObject.defineProperty(onCancel, 'isCancelled', {\r\n\t\t\t\tget: (): boolean => this._isCancelled,\r\n\t\t\t});\r\n\r\n\t\t\treturn executor(onResolve, onReject, onCancel as OnCancel);\r\n\t\t});\r\n\t}\r\n\r\n\tget [Symbol.toStringTag]() {\r\n\t\treturn 'Cancellable Promise';\r\n\t}\r\n\r\n\tpublic then<TResult1 = T, TResult2 = never>(\r\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\r\n\t\tonRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null,\r\n\t): Promise<TResult1 | TResult2> {\r\n\t\treturn this.promise.then(onFulfilled, onRejected);\r\n\t}\r\n\r\n\tpublic catch<TResult = never>(\r\n\t\tonRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null,\r\n\t): Promise<T | TResult> {\r\n\t\treturn this.promise.catch(onRejected);\r\n\t}\r\n\r\n\tpublic finally(onFinally?: (() => void) | null): Promise<T> {\r\n\t\treturn this.promise.finally(onFinally);\r\n\t}\r\n\r\n\tpublic cancel(): void {\r\n\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._isCancelled = true;\r\n\t\tif (this.cancelHandlers.length) {\r\n\t\t\ttry {\r\n\t\t\t\tfor (const cancelHandler of this.cancelHandlers) {\r\n\t\t\t\t\tcancelHandler();\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.warn('Cancellation threw an error', error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.cancelHandlers.length = 0;\r\n\t\tif (this._reject) this._reject(new UmbCancelError('Request aborted'));\r\n\t}\r\n\r\n\tpublic get isCancelled(): boolean {\r\n\t\treturn this._isCancelled;\r\n\t}\r\n}\r\n","import { UmbCancelablePromise } from '../cancelable-promise.js';\r\nimport { UmbApiError } from '../umb-error.js';\r\nimport { isProblemDetailsLike } from '../apiTypeValidators.function.js';\r\nimport type { UmbApiResponse, XhrRequestOptions } from '../types.js';\r\nimport { UmbTryExecuteController } from './try-execute.controller.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { umbHttpClient } from '@umbraco-cms/backoffice/http-client';\r\n\r\n/**\r\n * Make an XHR request.\r\n * This function is a wrapper around XMLHttpRequest to provide a consistent API for making requests.\r\n * It supports cancelable promises, progress events, and custom headers.\r\n * @param {UmbControllerHost} host The host to use for the request.\r\n * @param {XhrRequestOptions} options The options for the request.\r\n * @returns {Promise<UmbApiResponse<T>>} A promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n */\r\nexport async function tryXhrRequest<T>(\r\n\thost: UmbControllerHost,\r\n\toptions: XhrRequestOptions,\r\n): Promise<UmbApiResponse<T>> {\r\n\tconst config = umbHttpClient.getConfig();\r\n\tconst promise = createXhrRequest<T>({\r\n\t\t...options,\r\n\t\tbaseUrl: config.baseUrl,\r\n\t\ttoken: () => (typeof config.auth === 'function' ? config.auth({ type: 'http', scheme: 'bearer' }) : config.auth),\r\n\t});\r\n\tconst controller = new UmbTryExecuteController(host, promise);\r\n\tconst response = await controller.tryExecute(options);\r\n\tcontroller.destroy();\r\n\treturn response;\r\n}\r\n\r\n/**\r\n * Create an XHR request.\r\n * @param {XhrRequestOptions} options The options for the request.\r\n * @returns {UmbCancelablePromise<T>} A cancelable promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n * @internal\r\n */\r\nfunction createXhrRequest<T>(options: XhrRequestOptions): UmbCancelablePromise<T> {\r\n\tconst baseUrl = options.baseUrl || '/umbraco';\r\n\r\n\treturn new UmbCancelablePromise<T>(async (resolve, reject, onCancel) => {\r\n\t\tconst xhr = new XMLHttpRequest();\r\n\t\txhr.open(options.method, `${baseUrl}${options.url}`, true);\r\n\r\n\t\t// Set default headers\r\n\t\tif (options.token) {\r\n\t\t\tconst token = typeof options.token === 'function' ? await options.token() : options.token;\r\n\t\t\tif (token) {\r\n\t\t\t\txhr.setRequestHeader('Authorization', `Bearer ${token}`);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Infer Content-Type header based on body type\r\n\t\tif (options.body instanceof FormData) {\r\n\t\t\t// Note: 'multipart/form-data' is automatically set by the browser for FormData\r\n\t\t} else {\r\n\t\t\txhr.setRequestHeader('Content-Type', 'application/json');\r\n\t\t}\r\n\r\n\t\t// Set custom headers\r\n\t\tif (options.headers) {\r\n\t\t\tfor (const [key, value] of Object.entries(options.headers)) {\r\n\t\t\t\txhr.setRequestHeader(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\txhr.upload.onprogress = (event) => {\r\n\t\t\tif (options.onProgress) {\r\n\t\t\t\toptions.onProgress(event);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\txhr.onload = () => {\r\n\t\t\ttry {\r\n\t\t\t\tif (xhr.status >= 200 && xhr.status < 300) {\r\n\t\t\t\t\tif (options.responseHeader) {\r\n\t\t\t\t\t\tconst response = xhr.getResponseHeader(options.responseHeader);\r\n\t\t\t\t\t\tresolve(response as T);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresolve(JSON.parse(xhr.responseText));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treject(createErrorResponse(xhr));\r\n\t\t\t\t}\r\n\t\t\t} catch {\r\n\t\t\t\t// This most likely happens when the response is not JSON\r\n\t\t\t\treject(\r\n\t\t\t\t\tnew UmbApiError(`Failed to make request: ${xhr.statusText}`, xhr.status, xhr, {\r\n\t\t\t\t\t\ttitle: xhr.statusText,\r\n\t\t\t\t\t\ttype: 'ApiError',\r\n\t\t\t\t\t\tstatus: xhr.status,\r\n\t\t\t\t\t}),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\txhr.onerror = () => {\r\n\t\t\treject(createErrorResponse(xhr));\r\n\t\t};\r\n\r\n\t\tif (!onCancel.isCancelled) {\r\n\t\t\t// Handle body based on Content-Type\r\n\t\t\tif (options.body instanceof FormData) {\r\n\t\t\t\txhr.send(options.body);\r\n\t\t\t} else {\r\n\t\t\t\txhr.send(JSON.stringify(options.body));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tonCancel(() => {\r\n\t\t\txhr.abort();\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Create an error response from an XMLHttpRequest.\r\n * This function is used to create a consistent error response format for failed requests.\r\n * It extracts the status, statusText, and responseText from the XMLHttpRequest object and creates an UmbApiError object.\r\n * It tries to parse the responseText as JSON and, if successful, adds it to the UmbApiError object as UmbProblemDetails.\r\n * @param {XMLHttpRequest} xhr The XMLHttpRequest object\r\n * @returns {UmbApiError} An UmbApiError object containing the error details.\r\n * @internal\r\n */\r\nfunction createErrorResponse(xhr: XMLHttpRequest): UmbApiError {\r\n\tconst error = new UmbApiError(xhr.statusText, xhr.status, xhr, {\r\n\t\ttitle: xhr.statusText,\r\n\t\ttype: 'ApiError',\r\n\t\tstatus: xhr.status,\r\n\t});\r\n\ttry {\r\n\t\tconst errorBody = xhr.responseText;\r\n\t\tif (errorBody) {\r\n\t\t\tconst parsedError = JSON.parse(errorBody);\r\n\t\t\tif (parsedError && isProblemDetailsLike(parsedError)) {\r\n\t\t\t\terror.problemDetails = parsedError;\r\n\t\t\t}\r\n\t\t}\r\n\t} catch {\r\n\t\t// Ignore JSON parsing errors\r\n\t}\r\n\r\n\treturn error;\r\n}\r\n"],"names":["extractUmbNotificationColor","type","EventMessageTypeModel","objectIsUmbNotification","notification","object","isUmbNotifications","notifications","UMB_NOTIFICATION_HEADER","isApiError","error","isCancelError","isCancelablePromise","promise","isProblemDetailsLike","UmbApiInterceptorController","UmbControllerBase","client","response","authContext","UMB_AUTH_CONTEXT","#peekError","generatedResource","headline","message","e","umbNotifications","details","color","host","UmbError","UmbCancelError","UmbApiError","status","request","problemDetails","UmbResourceController","alias","UmbTryExecuteController","#abortSignal","opts","umbError","#notifyOnError","tryExecute","controller","batchTryExecute","chunks","callback","chunk","tryExecuteAndNotify","resource","UmbDeprecation","UmbCancelablePromise","executor","resolve","reject","onResolve","value","onReject","reason","onCancel","cancelHandler","onFulfilled","onRejected","onFinally","tryXhrRequest","options","config","umbHttpClient","createXhrRequest","baseUrl","xhr","token","key","event","createErrorResponse","errorBody","parsedError"],"mappings":";;;;;;AAUO,SAASA,EAA4BC,GAAmD;AAC9F,UAAQA,GAAM;AAAA,IACb,KAAKC,EAAsB;AACnB,aAAA;AAAA,IACR,KAAKA,EAAsB;AACnB,aAAA;AAAA,IACR,KAAKA,EAAsB;AAAA,IAC3B,KAAKA,EAAsB;AACnB,aAAA;AAAA,IACR,KAAKA,EAAsB;AACnB,aAAA;AAAA,IACR;AACQ,aAAA;AAAA,EAAA;AAEV;AClBA,SAASC,EAAwBC,GAAmE;AACnG,MAAI,OAAOA,KAAiB,YAAYA,MAAiB;AACjD,WAAA;AAER,QAAMC,IAASD;AACf,SACC,OAAOC,EAAO,YAAa,YAC3B,OAAOA,EAAO,WAAY,YAC1B,OAAOA,EAAO,QAAS,YACvB,OAAO,OAAOH,CAAqB,EAAE,SAASG,EAAO,IAAI;AAE3D;AAYO,SAASC,EAAmBC,GAAmF;AAC9G,SAAAA,EAAc,MAAMJ,CAAuB;AACnD;AAEO,MAAMK,IAA0B;ACzBhC,SAASC,EAAWC,GAAgF;AACnG,SAAA,OAAOA,KAAU,YAAYA,MAAU,QAAQ,UAAUA,KAAS,YAAYA,KAAS,aAAaA;AAC5G;AAQO,SAASC,EAAcD,GAAgC;AAC7D,SAAOA,aAAiB,UAAUA,EAAM,SAAS,iBAAkBA,EAAgB,YAAY;AAChG;AAOO,SAASE,EAAuBC,GAAkE;AACjG,SAAA,OAAQA,EAAgD,UAAW;AAC3E;AAOO,SAASC,EAAqBJ,GAA4C;AAChF,SACC,OAAOA,KAAU,YACjBA,MAAU,QACV,UAAUA,KACV,WAAWA,KACX,YAAYA,MACX,OAAQA,EAA+B,SAAW,OAClD,OAAQA,EAA+B,UAAW,cAClD,OAAQA,EAAiC,WAAa,OACtD,OAAQA,EAAiC,YAAa,cACtD,OAAQA,EAAwC,kBAAoB,OACpE,OAAQA,EAAwC,mBAAoB,cACpE,OAAQA,EAA+B,SAAW,OAClD,OAAQA,EAA+B,UAAW;AAErD;AC5CO,MAAMK,UAAoCC,EAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3D,wBAAwBC,GAA8B;AAC5D,SAAK,2BAA2BA,CAAM,GACtC,KAAK,mCAAmCA,CAAM,GAC9C,KAAK,+BAA+BA,CAAM,GAC1C,KAAK,gCAAgCA,CAAM,GAC3C,KAAK,oBAAoBA,CAAM;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQhC,2BAA2BA,GAA8B;AACxD,IAAAA,EAAO,aAAa,SAAS,IAAI,OAAOC,MAAuB;AAC1D,UAAAA,EAAS,WAAW,KAAK;AAEtB,cAAAC,IAAc,MAAM,KAAK,WAAWC,GAAkB,EAAE,gBAAgB,IAAM;AACpF,YAAI,CAACD;AACE,gBAAA,IAAI,MAAM,gCAAgC;AAEjD,QAAAA,EAAY,QAAQ;AAAA,MAAA;AAEd,aAAAD;AAAA,IAAA,CACP;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQF,gCAAgCD,GAA8B;AAC5D,IAAAA,EAAO,aAAa,SAAS,IAAI,OAAOC,OACnCA,EAAS,WAAW,OAIlB,KAAAG,GAHY,qBACD,wJAEmB,IAAI,GAGjCH,EACP;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQH,mCAAmCD,GAA8B;AAChE,IAAAA,EAAO,aAAa,SAAS,IAAI,OAAOC,MAAuB;AAC9D,UAAI,CAACA,EAAS,QAAQ,IAAI,wBAAwB;AAC1C,eAAAA;AAGR,YAAMI,IAAoBJ,EAAS,QAAQ,IAAI,wBAAwB;AACvE,aAAII,MAAsB,OAClBJ,IAIY,IAAI,SAASI,GAAmB;AAAA,QACnD,GAAGJ;AAAA,MAAA,CACH;AAAA,IAEM,CACP;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQF,oBAAoBD,GAA8B;AACjD,IAAAA,EAAO,aAAa,SAAS,IAAI,OAAOC,MAAa;AAChD,UAAAA,EAAS,GAAW,QAAAA;AAGpB,UAAAA,EAAS,WAAW;AACnB,YAAA;AAGG,gBAAAR,IAAQ,MADOQ,EAAS,MAAM,EACH,KAAK;AAMlC,cAHA,CAACR,KAGD,CAACI,EAAqBJ,CAAK;AAEvB,mBAAAQ;AAGJ,cAAAK,IAAWb,EAAM,SAAS,gBAC1Bc,IAAU;AAIb,WAAAd,EAAM,QAAQ,SAAS,qBAAqB,KAC5CA,EAAM,QAAQ,SAAS,6DAA6D,OAEzEa,IAAA,6BAEVC,IAAA,iKAGF,KAAKH,GAAWE,GAAUC,GAASd,EAAM,MAAM;AAAA,iBACvCe,GAAG;AAEH,kBAAA,MAAM,mFAAmFA,CAAC;AAAA,QAAA;AAK7F,aAAAP;AAAA,IAAA,CACP;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQF,+BAA+BD,GAA8B;AAC5D,IAAAA,EAAO,aAAa,SAAS,IAAI,CAACC,MAAa;AAG9C,YAAMQ,IAAmBR,EAAS,QAAQ,IAAIV,CAAuB;AACjE,UAAA,CAACkB,EAAyB,QAAAR;AAI1B,UAAA;AACG,cAAAX,IAAgB,KAAK,MAAMmB,CAAgB;AACjD,YAAI,CAACpB,EAAmBC,CAAa,EAAU,QAAAW;AAE/C,mBAAWd,KAAgBG;AACrB,eAAAc;AAAA,YACJjB,EAAa;AAAA,YACbA,EAAa;AAAA,YACb;AAAA,YACAJ,EAA4BI,EAAa,IAAI;AAAA,UAC9C;AAAA,MACD,QACO;AAAA,MAAA;AAID,aAAAc;AAAA,IAAA,CACP;AAAA,EAAA;AAAA,EAGF,MAAMG,GAAWE,GAAkBC,GAAiBG,GAAkBC,GAA8B;AAEnG,UAAMC,IAAO,KAAK;AAGlB,KAAC,MAAM,OAAO,sCAAsC,GAAG,aAAaA,GAAM;AAAA,MACzE,UAAAN;AAAA,MACA,SAAAC;AAAA,MACA,SAAAG;AAAA,MACA,OAAAC;AAAA,IAAA,CACA;AAAA,EAAA;AAEH;AClLO,MAAME,UAAiB,MAAM;AAAA,EAA7B,cAAA;AAAA,UAAA,GAAA,SAAA,GACN,KAAgB,OAAO;AAAA,EAAA;AAAA,EAEvB,OAAc,WAAWpB,GAAmC;AACpD,WAAAA,aAAiBoB,KAAapB,EAAmB,SAAS;AAAA,EAAA;AAEnE;AAEO,MAAMqB,UAAuBD,EAAS;AAAA,EAAtC,cAAA;AAAA,UAAA,GAAA,SAAA,GACN,KAAgB,OAAO;AAAA,EAAA;AAAA,EAEvB,OAAc,iBAAiBpB,GAAyC;AAChE,WAAAA,aAAiBqB,KAAmBrB,EAAyB,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS9E,OAAc,sBAAsBA,GAA8B;AAC1D,WAAA,IAAIqB,EAAerB,EAAM,OAAO;AAAA,EAAA;AAEzC;AAKO,MAAMsB,UAAoBF,EAAS;AAAA,EAMlC,YAAYN,GAAiBS,GAAgBC,GAAkBC,GAAmC;AACxG,UAAMX,CAAO,GANd,KAAgB,OAAO,eAOtB,KAAK,SAASS,GACd,KAAK,UAAUC,GACf,KAAK,iBAAiBC;AAAA,EAAA;AAAA,EAGvB,OAAc,cAAczB,GAAsC;AAC1D,WAAAA,aAAiBsB,KAAgBtB,EAAsB,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASxE,OAAc,mBAAmBA,GAAmF;AAEnH,QAAIyB,IAA2C;AAC/C,QAAI,OAAOzB,EAAM,OAAS,OAAiBA,EAAM;AAC5C,UAAA;AACc,QAAAyB,IAAA,OAAOzB,EAAM,QAAS,WAAW,KAAK,MAAMA,EAAM,IAAI,IAAIA,EAAM;AAAA,eACzEe,GAAG;AACH,gBAAA,MAAM,4CAA4CA,CAAC;AAAA,MAAA;AAG7D,WAAO,IAAIO;AAAA,MACVtB,EAAM;AAAA,MACNA,EAAM,UAAU;AAAA,MAChBA,EAAM;AAAA,MACNyB,KAAkB,EAAE,OAAOzB,EAAM,SAAS,MAAM,YAAY,QAAQA,EAAM,UAAU,EAAE;AAAA,IACvF;AAAA,EAAA;AAEF;AClEO,MAAM0B,UAA2CpB,EAAkB;AAAA,EAOzE,YAAYa,GAAyBhB,GAAyBwB,GAAgB;AAC7E,UAAMR,GAAMQ,CAAK,GAEjB,KAAK,WAAWxB;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASjB,cAAcH,GAAyD;AAClE,WAAAI,EAAqBJ,CAAK,IACtB,IAAIsB,EAAYtB,EAAM,UAAUA,EAAM,OAAOA,EAAM,QAAQ,MAAMA,CAAK,IACnED,EAAWC,CAAK,IACnBsB,EAAY,mBAAmBtB,CAAc,IAC1CC,EAAcD,CAAK,IACtBqB,EAAe,sBAAsBrB,CAAK,IACvCqB,EAAe,iBAAiBrB,CAAK,KAErCsB,EAAY,cAActB,CAAK,KAE/BoB,EAAS,WAAWpB,CAAK,IAH5BA,IAOD,IAAIoB,EAASpB,aAAiB,QAAQA,EAAM,UAAU,eAAe;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa7E,SAAe;AACV,IAAAE,EAAoB,KAAK,QAAQ,KACpC,KAAK,SAAS,OAAO;AAAA,EACtB;AAAA,EAGQ,mBAAyB;AACjC,UAAM,iBAAiB,GACvB,KAAK,OAAO;AAAA,EAAA;AAAA,EAGJ,UAAgB;AACxB,UAAM,QAAQ,GACd,KAAK,OAAO;AAAA,EAAA;AAAA,EAGb,MAAgB,WAAWW,GAAkBC,GAAiBG,GAAkB;AAE/E,UAAME,IAAO,KAAK;AAGlB,KAAC,MAAM,OAAO,sCAAsC,GAAG,aAAaA,GAAM;AAAA,MACzE,UAAAN;AAAA,MACA,SAAAC;AAAA,MACA,SAAAG;AAAA,IAAA,CACA;AAAA,EAAA;AAEH;AC1EO,MAAMW,UAAmCF,EAAyB;AAAA,EACxEG;AAAA,EAEA,MAAM,WAAWC,GAAyD;AACrE,QAAA;AACH,aAAIA,GAAM,gBACT,KAAKD,KAAeC,EAAK,aACpB,KAAAD,GAAa,iBAAiB,SAAS,MAAM,KAAK,UAAU,EAAE,MAAM,IAAM,IAGxE,MAAM,KAAK;AAAA,aACX7B,GAAO;AAET,YAAA+B,IAAW,KAAK,cAAc/B,CAAK;AAErC,aAAC8B,GAAM,wBACV,KAAKE,GAAeD,CAAQ,GAGtB;AAAA,QACN,OAAOA;AAAA,MACR;AAAA,IAAA;AAAA,EACD;AAAA,EAGQ,UAAgB;AACxB,IAAI,KAAKF,MACR,KAAKA,GAAa,oBAAoB,SAAS,KAAK,MAAM,GAE3D,MAAM,QAAQ;AAAA,EAAA;AAAA,EAGfG,GAAehC,GAAgB;AAC1B,QAAAqB,EAAe,iBAAiBrB,CAAK;AAExC;AAGD,QAAIa,IAAW,qBACXC,IAAU,0DACVG;AAGE,UAAAQ,IAAiBH,EAAY,cAActB,CAAK,IACnDA,EAAM,iBACNI,EAAqBJ,CAAK,IACzBA,IACA;AAEJ,IAAIyB,KAEHX,IAAUW,EAAe,OACzBR,IAAUQ,EAAe,UAAU,WAGxBZ,IAAA,IACDC,IAAAd,aAAiB,QAAQA,EAAM,UAAU,+BAG/C,KAAA,WAAWa,GAAUC,GAASG,CAAO;AAAA,EAAA;AAE5C;AC9CsB,eAAAgB,EACrBd,GACAhB,GACA2B,GAC6B;AAC7B,QAAMI,IAAa,IAAIN,EAAwBT,GAAMhB,CAAO,GACtDK,IAAW,MAAM0B,EAAW,WAAWJ,CAAI;AACjD,SAAAI,EAAW,QAAQ,GACZ1B;AACR;ACnBgB,SAAA2B,EACfhB,GACAiB,GACAC,GACiD;AACjD,SAAO,QAAQ,WAAWD,EAAO,IAAI,CAACE,MAAUL,EAAWd,GAAMkB,EAASC,CAAK,GAAG,EAAE,sBAAsB,GAAK,CAAC,CAAC,CAAC;AACnH;ACAsB,eAAAC,EACrBpB,GACAqB,GAC6B;AAC7B,MAAIC,EAAe;AAAA,IAClB,YAAY;AAAA,IACZ,iBAAiB;AAAA,IACjB,UAAU;AAAA,EACV,CAAA,EAAE,KAAK;AACR,QAAMP,IAAa,IAAIN,EAAwBT,GAAMqB,CAAQ,GACvDhC,IAAW,MAAM0B,EAAW,WAAW,EAAE,sBAAsB,IAAO;AAC5E,SAAAA,EAAW,QAAQ,GACZ1B;AACR;ACnBO,MAAMkC,EAA8C;AAAA,EAS1D,YACCC,GAKC;AACD,SAAK,cAAc,IACnB,KAAK,cAAc,IACnB,KAAK,eAAe,IACpB,KAAK,iBAAiB,CAAC,GACvB,KAAK,UAAU,IAAI,QAAW,CAACC,GAASC,MAAW;AAClD,WAAK,WAAWD,GAChB,KAAK,UAAUC;AAET,YAAAC,IAAY,CAACC,MAAoC;AACtD,QAAI,KAAK,eAAe,KAAK,eAAe,KAAK,iBAGjD,KAAK,cAAc,IACf,KAAK,YAAe,KAAA,SAASA,CAAK;AAAA,MACvC,GAEMC,IAAW,CAACC,MAA2B;AAC5C,QAAI,KAAK,eAAe,KAAK,eAAe,KAAK,iBAGjD,KAAK,cAAc,IACf,KAAK,WAAc,KAAA,QAAQA,CAAM;AAAA,MACtC,GAEMC,IAAW,CAACC,MAAoC;AACrD,QAAI,KAAK,eAAe,KAAK,eAAe,KAAK,gBAG5C,KAAA,eAAe,KAAKA,CAAa;AAAA,MACvC;AAEO,oBAAA,eAAeD,GAAU,cAAc;AAAA,QAC7C,KAAK,MAAe,KAAK;AAAA,MAAA,CACzB,GAEM,OAAA,eAAeA,GAAU,cAAc;AAAA,QAC7C,KAAK,MAAe,KAAK;AAAA,MAAA,CACzB,GAEM,OAAA,eAAeA,GAAU,eAAe;AAAA,QAC9C,KAAK,MAAe,KAAK;AAAA,MAAA,CACzB,GAEMP,EAASG,GAAWE,GAAUE,CAAoB;AAAA,IAAA,CACzD;AAAA,EAAA;AAAA,EAGF,KAAK,OAAO,WAAW,IAAI;AACnB,WAAA;AAAA,EAAA;AAAA,EAGD,KACNE,GACAC,GAC+B;AAC/B,WAAO,KAAK,QAAQ,KAAKD,GAAaC,CAAU;AAAA,EAAA;AAAA,EAG1C,MACNA,GACuB;AAChB,WAAA,KAAK,QAAQ,MAAMA,CAAU;AAAA,EAAA;AAAA,EAG9B,QAAQC,GAA6C;AACpD,WAAA,KAAK,QAAQ,QAAQA,CAAS;AAAA,EAAA;AAAA,EAG/B,SAAe;AACrB,QAAI,OAAK,eAAe,KAAK,eAAe,KAAK,eAI7C;AAAA,UADJ,KAAK,eAAe,IAChB,KAAK,eAAe;AACnB,YAAA;AACQ,qBAAAH,KAAiB,KAAK;AAClB,YAAAA,EAAA;AAAA,iBAEPnD,GAAO;AACP,kBAAA,KAAK,+BAA+BA,CAAK;AACjD;AAAA,QAAA;AAGF,WAAK,eAAe,SAAS,GACzB,KAAK,WAAS,KAAK,QAAQ,IAAIqB,EAAe,iBAAiB,CAAC;AAAA;AAAA,EAAA;AAAA,EAGrE,IAAW,cAAuB;AACjC,WAAO,KAAK;AAAA,EAAA;AAEd;ACnGsB,eAAAkC,EACrBpC,GACAqC,GAC6B;AACvB,QAAAC,IAASC,EAAc,UAAU,GACjCvD,IAAUwD,EAAoB;AAAA,IACnC,GAAGH;AAAA,IACH,SAASC,EAAO;AAAA,IAChB,OAAO,MAAO,OAAOA,EAAO,QAAS,aAAaA,EAAO,KAAK,EAAE,MAAM,QAAQ,QAAQ,SAAU,CAAA,IAAIA,EAAO;AAAA,EAAA,CAC3G,GACKvB,IAAa,IAAIN,EAAwBT,GAAMhB,CAAO,GACtDK,IAAW,MAAM0B,EAAW,WAAWsB,CAAO;AACpD,SAAAtB,EAAW,QAAQ,GACZ1B;AACR;AASA,SAASmD,EAAoBH,GAAqD;AAC3E,QAAAI,IAAUJ,EAAQ,WAAW;AAEnC,SAAO,IAAId,EAAwB,OAAOE,GAASC,GAAQK,MAAa;AACjE,UAAAW,IAAM,IAAI,eAAe;AAI/B,QAHIA,EAAA,KAAKL,EAAQ,QAAQ,GAAGI,CAAO,GAAGJ,EAAQ,GAAG,IAAI,EAAI,GAGrDA,EAAQ,OAAO;AACZ,YAAAM,IAAQ,OAAON,EAAQ,SAAU,aAAa,MAAMA,EAAQ,UAAUA,EAAQ;AACpF,MAAIM,KACHD,EAAI,iBAAiB,iBAAiB,UAAUC,CAAK,EAAE;AAAA,IACxD;AAWD,QAPIN,EAAQ,gBAAgB,YAGvBK,EAAA,iBAAiB,gBAAgB,kBAAkB,GAIpDL,EAAQ;AACA,iBAAA,CAACO,GAAKhB,CAAK,KAAK,OAAO,QAAQS,EAAQ,OAAO;AACpD,QAAAK,EAAA,iBAAiBE,GAAKhB,CAAK;AAI7B,IAAAc,EAAA,OAAO,aAAa,CAACG,MAAU;AAClC,MAAIR,EAAQ,cACXA,EAAQ,WAAWQ,CAAK;AAAA,IAE1B,GAEAH,EAAI,SAAS,MAAM;AACd,UAAA;AACH,YAAIA,EAAI,UAAU,OAAOA,EAAI,SAAS;AACrC,cAAIL,EAAQ,gBAAgB;AAC3B,kBAAMhD,IAAWqD,EAAI,kBAAkBL,EAAQ,cAAc;AAC7D,YAAAZ,EAAQpC,CAAa;AAAA,UAAA;AAErB,YAAAoC,EAAQ,KAAK,MAAMiB,EAAI,YAAY,CAAC;AAAA;AAG9B,UAAAhB,EAAAoB,EAAoBJ,CAAG,CAAC;AAAA,MAChC,QACO;AAEP,QAAAhB;AAAA,UACC,IAAIvB,EAAY,2BAA2BuC,EAAI,UAAU,IAAIA,EAAI,QAAQA,GAAK;AAAA,YAC7E,OAAOA,EAAI;AAAA,YACX,MAAM;AAAA,YACN,QAAQA,EAAI;AAAA,UACZ,CAAA;AAAA,QACF;AAAA,MAAA;AAAA,IAEF,GAEAA,EAAI,UAAU,MAAM;AACZ,MAAAhB,EAAAoB,EAAoBJ,CAAG,CAAC;AAAA,IAChC,GAEKX,EAAS,gBAETM,EAAQ,gBAAgB,WACvBK,EAAA,KAAKL,EAAQ,IAAI,IAErBK,EAAI,KAAK,KAAK,UAAUL,EAAQ,IAAI,CAAC,IAIvCN,EAAS,MAAM;AACd,MAAAW,EAAI,MAAM;AAAA,IAAA,CACV;AAAA,EAAA,CACD;AACF;AAWA,SAASI,EAAoBJ,GAAkC;AAC9D,QAAM7D,IAAQ,IAAIsB,EAAYuC,EAAI,YAAYA,EAAI,QAAQA,GAAK;AAAA,IAC9D,OAAOA,EAAI;AAAA,IACX,MAAM;AAAA,IACN,QAAQA,EAAI;AAAA,EAAA,CACZ;AACG,MAAA;AACH,UAAMK,IAAYL,EAAI;AACtB,QAAIK,GAAW;AACR,YAAAC,IAAc,KAAK,MAAMD,CAAS;AACpC,MAAAC,KAAe/D,EAAqB+D,CAAW,MAClDnE,EAAM,iBAAiBmE;AAAA,IACxB;AAAA,EACD,QACO;AAAA,EAAA;AAID,SAAAnE;AACR;"}