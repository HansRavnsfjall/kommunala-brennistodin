{"version":3,"file":"token-check.worker-BA0acAb6.js","sources":["../auth/workers/token-check.worker.ts"],"sourcesContent":["import type { TokenResponse } from '@umbraco-cms/backoffice/external/openid';\r\n\r\n/**\r\n * Applies a buffer time before the actual expiration of the token.\r\n * This is to ensure that we have time to refresh the token before it expires.\r\n */\r\nconst BUFFER_BEFORE_EXPIRATION = 60; // 1 minute in seconds\r\n\r\n/**\r\n * The interval at which the token will be validated.\r\n */\r\nconst VALIDATION_INTERVAL = 30000; // 30 seconds in milliseconds\r\n\r\n/**\r\n * The multiplier for the token expiry time.\r\n * In Umbraco, access_tokens live for a quarter of the time of the refresh_token.\r\n */\r\nconst TOKEN_EXPIRY_MULTIPLIER = 4;\r\n\r\nconst ports: MessagePort[] = [];\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nlet interval: any;\r\n\r\nconsole.log('[Token Check Worker] Token check worker initialized.');\r\n\r\n/**\r\n * Define the globalThis object to handle the onconnect event as SharedWorkerGlobalScope.\r\n * This must be defined manually because TypeScript does not recognize the SharedWorkerGlobalScope type on all environments.\r\n */\r\nconst _self = globalThis as typeof globalThis & {\r\n\tonconnect: (event: MessageEvent) => void;\r\n};\r\n\r\n_self.onconnect = (event: MessageEvent) => {\r\n\tconsole.log('[Token Check Worker] Connected to main thread.');\r\n\tconst port = event.ports[0];\r\n\r\n\tports.push(port);\r\n\r\n\t// Listen for messages from any port connected to this worker\r\n\tport.onmessage = (e: MessageEvent) => {\r\n\t\tif (e.data?.command === 'init') {\r\n\t\t\tconsole.log('[Token Check Worker] Initializing with token response:', e.data.tokenResponse);\r\n\t\t\tif (e.data.tokenResponse) {\r\n\t\t\t\tinit(e.data.tokenResponse);\r\n\t\t\t} else if (interval) {\r\n\t\t\t\tconsole.warn('[Token Check Worker] No token response provided, stopping the interval.');\r\n\t\t\t\tclearInterval(interval);\r\n\t\t\t\tinterval = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n\r\n/**\r\n * Checks if the provided token is expired.\r\n * If the token is not provided, it is considered expired.\r\n * @param {TokenResponse} token - The token response to check.\r\n * @returns {object} An object containing:\r\n * - tokenIsExpired: A boolean indicating if the token is expired.\r\n * - numberOfSecondsUntilExpiration: The number of seconds until the token expires, or 0 if it is expired.\r\n */\r\nfunction isTokenExpired(token: TokenResponse) {\r\n\tconst currentTime = Math.floor(Date.now() / 1000);\r\n\tconst tokenExpiresAt = token.issuedAt + (token.expiresIn ?? 1) * TOKEN_EXPIRY_MULTIPLIER;\r\n\tconst tokenExpiresInSeconds = tokenExpiresAt - currentTime;\r\n\r\n\tconsole.log('[Token Check Worker] Token expires in', tokenExpiresInSeconds, 'seconds');\r\n\r\n\tlet tokenExpiresInSecondsWithBuffer = tokenExpiresInSeconds - BUFFER_BEFORE_EXPIRATION;\r\n\tif (tokenExpiresInSecondsWithBuffer < 0) {\r\n\t\ttokenExpiresInSecondsWithBuffer = 0;\r\n\t}\r\n\r\n\tconst tokenIsExpired = tokenExpiresInSecondsWithBuffer === 0;\r\n\r\n\treturn {\r\n\t\ttokenIsExpired,\r\n\t\tnumberOfSecondsUntilExpiration: tokenExpiresInSecondsWithBuffer,\r\n\t};\r\n}\r\n\r\n/**\r\n * This worker checks the token expiration at regular intervals.\r\n * If the token is expired or missing, it will trigger a logout.\r\n * @param {TokenResponse} tokenResponse - The token response to check.\r\n */\r\nfunction init(tokenResponse: TokenResponse) {\r\n\tconsole.log('[Token Check Worker] Initializing token check worker...');\r\n\r\n\tif (interval) {\r\n\t\tclearInterval(interval);\r\n\t}\r\n\r\n\tinterval = setInterval(() => {\r\n\t\tconst result = isTokenExpired(tokenResponse);\r\n\r\n\t\tif (result.tokenIsExpired) {\r\n\t\t\tconsole.log('[Token Check Worker] Token is expired or missing, triggering logout.');\r\n\t\t\t// Trigger logout logic here, e.g., send a message to all connected ports\r\n\t\t\tfor (const port of ports) {\r\n\t\t\t\tif (port) {\r\n\t\t\t\t\tport.postMessage({ command: 'logout' });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tclearInterval(interval);\r\n\t\t\tinterval = undefined;\r\n\t\t\tconsole.log('[Token Check Worker] Waiting for token refresh...');\r\n\t\t} else if (result.numberOfSecondsUntilExpiration <= BUFFER_BEFORE_EXPIRATION) {\r\n\t\t\tconsole.log('[Token Check Worker] Token should be refreshed, but it is not expired yet.');\r\n\t\t\t// Let all connected clients know that the token should be refreshed\r\n\t\t\tfor (const port of ports) {\r\n\t\t\t\tif (port) {\r\n\t\t\t\t\tport.postMessage({\r\n\t\t\t\t\t\tcommand: 'refreshToken',\r\n\t\t\t\t\t\tsecondsUntilLogout: result.numberOfSecondsUntilExpiration,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}, VALIDATION_INTERVAL);\r\n}\r\n"],"names":["ports","interval","_self","event","port","init","isTokenExpired","token","currentTime","tokenExpiresInSeconds","tokenExpiresInSecondsWithBuffer","tokenResponse","result"],"mappings":"yBAmBA,MAAMA,EAAuB,CAAA,EAG7B,IAAIC,EAEJ,QAAQ,IAAI,sDAAsD,EAMlE,MAAMC,EAAQ,WAIdA,EAAM,UAAaC,GAAwB,CAC1C,QAAQ,IAAI,gDAAgD,EAC5D,MAAMC,EAAOD,EAAM,MAAM,CAAC,EAE1BH,EAAM,KAAKI,CAAI,EAGfA,EAAK,UAAa,GAAoB,CACjC,EAAE,MAAM,UAAY,SACvB,QAAQ,IAAI,yDAA0D,EAAE,KAAK,aAAa,EACtF,EAAE,KAAK,cACVC,EAAK,EAAE,KAAK,aAAa,EACfJ,IACV,QAAQ,KAAK,yEAAyE,EACtF,cAAcA,CAAQ,EACtBA,EAAW,QAGd,CACD,EAUA,SAASK,EAAeC,EAAsB,CAC7C,MAAMC,EAAc,KAAK,MAAM,KAAK,IAAA,EAAQ,GAAI,EAE1CC,EADiBF,EAAM,UAAYA,EAAM,WAAa,GAAK,EAClBC,EAE/C,QAAQ,IAAI,wCAAyCC,EAAuB,SAAS,EAErF,IAAIC,EAAkCD,EAAwB,GAC9D,OAAIC,EAAkC,IACrCA,EAAkC,GAK5B,CACN,eAHsBA,IAAoC,EAI1D,+BAAgCA,CAAA,CAElC,CAOA,SAASL,EAAKM,EAA8B,CAC3C,QAAQ,IAAI,yDAAyD,EAEjEV,GACH,cAAcA,CAAQ,EAGvBA,EAAW,YAAY,IAAM,CAC5B,MAAMW,EAASN,EAAeK,CAAa,EAE3C,GAAIC,EAAO,eAAgB,CAC1B,QAAQ,IAAI,sEAAsE,EAElF,UAAWR,KAAQJ,EACdI,GACHA,EAAK,YAAY,CAAE,QAAS,QAAA,CAAU,EAGxC,cAAcH,CAAQ,EACtBA,EAAW,OACX,QAAQ,IAAI,mDAAmD,CAChE,SAAWW,EAAO,gCAAkC,GAA0B,CAC7E,QAAQ,IAAI,4EAA4E,EAExF,UAAWR,KAAQJ,EACdI,GACHA,EAAK,YAAY,CAChB,QAAS,eACT,mBAAoBQ,EAAO,8BAAA,CAC3B,CAGJ,CACD,EAAG,GAAmB,CACvB"}