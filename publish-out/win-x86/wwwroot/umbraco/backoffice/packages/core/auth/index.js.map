{"version":3,"file":"index.js","sources":["../../../../src/packages/core/auth/components/auth-provider-default.element.ts","../../../../src/packages/core/auth/constants.ts","../../../../src/packages/core/auth/auth-flow.ts","../../../../src/packages/core/auth/modals/umb-auth-timeout-modal.token.ts","../../../../src/packages/core/auth/controllers/auth-session-timeout.controller.ts","../../../../src/packages/core/auth/auth.context.ts","../../../../src/packages/core/auth/modals/umb-app-auth-modal.token.ts"],"sourcesContent":["import type { UmbAuthProviderDefaultProps, UmbUserLoginState } from '../types.js';\r\nimport type { ManifestAuthProvider } from '../auth-provider.extension.js';\r\nimport { css, customElement, html, nothing, property } from '@umbraco-cms/backoffice/external/lit';\r\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\r\nimport { UmbTextStyles } from '@umbraco-cms/backoffice/style';\r\n\r\n@customElement('umb-auth-provider-default')\r\nexport class UmbAuthProviderDefaultElement extends UmbLitElement implements UmbAuthProviderDefaultProps {\r\n\t@property({ attribute: false })\r\n\tuserLoginState?: UmbUserLoginState | undefined;\r\n\r\n\t@property({ attribute: false })\r\n\tmanifest!: ManifestAuthProvider;\r\n\r\n\t@property({ attribute: false })\r\n\tonSubmit!: (manifestOrProviderName: string | ManifestAuthProvider, loginHint?: string) => void;\r\n\r\n\toverride connectedCallback(): void {\r\n\t\tsuper.connectedCallback();\r\n\t\tthis.setAttribute('part', 'auth-provider-default');\r\n\t}\r\n\r\n\tget #label() {\r\n\t\tconst label = this.manifest.meta?.label ?? this.manifest.forProviderName;\r\n\t\tconst labelLocalized = this.localize.string(label);\r\n\t\treturn this.localize.term('login_signInWith', labelLocalized);\r\n\t}\r\n\r\n\toverride render() {\r\n\t\treturn html`\r\n\t\t\t<uui-button\r\n\t\t\t\ttype=\"button\"\r\n\t\t\t\t@click=${() => this.onSubmit(this.manifest)}\r\n\t\t\t\tid=\"auth-provider-button\"\r\n\t\t\t\t.label=${this.#label}\r\n\t\t\t\t.look=${this.manifest.meta?.defaultView?.look ?? 'outline'}\r\n\t\t\t\t.color=${this.manifest.meta?.defaultView?.color ?? 'default'}>\r\n\t\t\t\t${this.manifest.meta?.defaultView?.icon\r\n\t\t\t\t\t? html`<uui-icon id=\"icon\" .name=${this.manifest.meta?.defaultView?.icon}></uui-icon>`\r\n\t\t\t\t\t: nothing}\r\n\t\t\t\t${this.#label}\r\n\t\t\t</uui-button>\r\n\t\t`;\r\n\t}\r\n\r\n\tstatic override styles = [\r\n\t\tUmbTextStyles,\r\n\t\tcss`\r\n\t\t\t:host {\r\n\t\t\t\tdisplay: block;\r\n\t\t\t}\r\n\r\n\t\t\t#auth-provider-button {\r\n\t\t\t\twidth: 100%;\r\n\t\t\t}\r\n\r\n\t\t\t#icon {\r\n\t\t\t\tmargin-right: var(--uui-size-space-1);\r\n\t\t\t}\r\n\t\t`,\r\n\t];\r\n}\r\n\r\ndeclare global {\r\n\tinterface HTMLElementTagNameMap {\r\n\t\t'umb-auth-provider-default': UmbAuthProviderDefaultElement;\r\n\t}\r\n}\r\n","export const UMB_STORAGE_TOKEN_RESPONSE_NAME = 'umb:userAuthTokenResponse';\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/*\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\r\n * use this file except in compliance with the License. You may obtain a copy of\r\n * the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations under\r\n * the License.\r\n */\r\nimport { UMB_STORAGE_TOKEN_RESPONSE_NAME } from './constants.js';\r\nimport type { LocationLike, StringMap } from '@umbraco-cms/backoffice/external/openid';\r\nimport {\r\n\tBaseTokenRequestHandler,\r\n\tBasicQueryStringUtils,\r\n\tFetchRequestor,\r\n\tLocalStorageBackend,\r\n\tRedirectRequestHandler,\r\n\tAuthorizationRequest,\r\n\tAuthorizationNotifier,\r\n\tAuthorizationServiceConfiguration,\r\n\tGRANT_TYPE_AUTHORIZATION_CODE,\r\n\tGRANT_TYPE_REFRESH_TOKEN,\r\n\tRevokeTokenRequest,\r\n\tTokenRequest,\r\n\tTokenResponse,\r\n} from '@umbraco-cms/backoffice/external/openid';\r\nimport { Subject } from '@umbraco-cms/backoffice/external/rxjs';\r\nimport { UmbObjectState } from '@umbraco-cms/backoffice/observable-api';\r\n\r\nconst requestor = new FetchRequestor();\r\n\r\n/**\r\n * This class is needed to prevent the hash from being parsed as part of the query string.\r\n */\r\nclass UmbNoHashQueryStringUtils extends BasicQueryStringUtils {\r\n\toverride parse(input: LocationLike) {\r\n\t\treturn super.parse(input, false);\r\n\t}\r\n}\r\n\r\n/**\r\n * This class is used to handle the auth flow through any backend supporting OpenID Connect.\r\n * It needs to know the server url, the client id, the redirect uri and the scope.\r\n *\r\n * For a default Umbraco installation, the server url is the base url of the Umbraco server.\r\n * and the client id is \"umbraco-back-office\"\r\n * and the scope is \"offline_access\"\r\n *\r\n * It will:\r\n * - Fetch the service configuration from the server\r\n * - Check if there is a token response in local storage\r\n * - If there is a token response, check if it is valid\r\n * - If it is not valid, check if there is a new authorization to be made\r\n * - If there is a new authorization to be made, complete it\r\n * - If there is no token response, check if there is a new authorization to be made\r\n * - If there is a new authorization to be made, complete it\r\n * - If there is no new authorization to be made, do nothing (= logged in)\r\n *\r\n * It will also:\r\n * - Save the token response in local storage\r\n * - Save the authorization code in local storage\r\n *\r\n * It will also provide methods to:\r\n * - Make a refresh token request\r\n * - Perform an action with fresh tokens\r\n * - Clear the token state (logout)\r\n *\r\n * It should be used as follows:\r\n * 1. Create an instance of this class\r\n * 2. Call the `setInitialState` method on startup\r\n *   a. This will fetch the service configuration and check if there is a token response in the storage backend\r\n *   b. If there is a token response, it will check if it is valid and if it is not, it will check if there is a new authorization to be made\r\n *     which happens when the user is redirected back to the app after logging in\r\n * 3. Call the `makeAuthorizationRequest` method on all pages that need to be authorized\r\n *   a. This will redirect the user to the authorization endpoint of the server\r\n * 4. After login, get the latest token before each request to the server by calling the `performWithFreshTokens` method\r\n */\r\nexport class UmbAuthFlow {\r\n\t// handlers\r\n\treadonly #notifier: AuthorizationNotifier;\r\n\treadonly #authorizationHandler: RedirectRequestHandler;\r\n\treadonly #tokenHandler: BaseTokenRequestHandler;\r\n\treadonly #storageBackend: LocalStorageBackend;\r\n\r\n\t// state\r\n\treadonly #configuration: AuthorizationServiceConfiguration;\r\n\treadonly #redirectUri: string;\r\n\treadonly #postLogoutRedirectUri: string;\r\n\treadonly #clientId: string;\r\n\treadonly #scope: string;\r\n\r\n\t// tokens\r\n\t#tokenResponse = new UmbObjectState<TokenResponse | undefined>(undefined);\r\n\treadonly token$ = this.#tokenResponse.asObservable();\r\n\r\n\t// external login\r\n\t#link_endpoint;\r\n\t#link_key_endpoint;\r\n\t#unlink_endpoint;\r\n\r\n\t/**\r\n\t * This signal will emit when the authorization flow is complete.\r\n\t * @remark It will also emit if there is an error during the authorization flow.\r\n\t */\r\n\treadonly authorizationSignal = new Subject<void>();\r\n\r\n\tconstructor(\r\n\t\topenIdConnectUrl: string,\r\n\t\tredirectUri: string,\r\n\t\tpostLogoutRedirectUri: string,\r\n\t\tclientId = 'umbraco-back-office',\r\n\t\tscope = 'offline_access',\r\n\t) {\r\n\t\tthis.#redirectUri = redirectUri;\r\n\t\tthis.#postLogoutRedirectUri = postLogoutRedirectUri;\r\n\t\tthis.#clientId = clientId;\r\n\t\tthis.#scope = scope;\r\n\r\n\t\tthis.#configuration = new AuthorizationServiceConfiguration({\r\n\t\t\tauthorization_endpoint: `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/authorize`,\r\n\t\t\ttoken_endpoint: `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/token`,\r\n\t\t\trevocation_endpoint: `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/revoke`,\r\n\t\t\tend_session_endpoint: `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/signout`,\r\n\t\t});\r\n\r\n\t\tthis.#link_endpoint = `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/link-login`;\r\n\t\tthis.#link_key_endpoint = `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/link-login-key`;\r\n\t\tthis.#unlink_endpoint = `${openIdConnectUrl}/umbraco/management/api/v1/security/back-office/unlink-login`;\r\n\r\n\t\tthis.#notifier = new AuthorizationNotifier();\r\n\t\tthis.#tokenHandler = new BaseTokenRequestHandler(requestor);\r\n\t\tthis.#storageBackend = new LocalStorageBackend();\r\n\t\tthis.#authorizationHandler = new RedirectRequestHandler(this.#storageBackend, new UmbNoHashQueryStringUtils());\r\n\r\n\t\t// set notifier to deliver responses\r\n\t\tthis.#authorizationHandler.setAuthorizationNotifier(this.#notifier);\r\n\r\n\t\t// set a listener to listen for authorization responses\r\n\t\tthis.#notifier.setAuthorizationListener(async (request, response, error) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tconsole.error('Authorization error', error);\r\n\t\t\t\tthis.authorizationSignal.next();\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\r\n\t\t\tif (response) {\r\n\t\t\t\tlet codeVerifier: string | undefined;\r\n\t\t\t\tif (request.internal && request.internal.code_verifier) {\r\n\t\t\t\t\tcodeVerifier = request.internal.code_verifier;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tawait this.#makeTokenRequest(response.code, codeVerifier);\r\n\t\t\t\tawait this.performWithFreshTokens();\r\n\t\t\t\tawait this.#saveTokenState();\r\n\t\t\t}\r\n\r\n\t\t\tthis.authorizationSignal.next();\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * This method will initialize all the state needed for the auth flow.\r\n\t *\r\n\t * It will:\r\n\t * - Check if there is a token response in local storage\r\n\t * - If there is a token response, check if it is valid\r\n\t * - If it is not valid, check if there is a new authorization to be made\r\n\t * - If there is a new authorization to be made, complete it\r\n\t * - If there is no token response, check if there is a new authorization to be made\r\n\t * - If there is a new authorization to be made, complete it\r\n\t */\r\n\tasync setInitialState() {\r\n\t\tconst tokenResponseJson = await this.#storageBackend.getItem(UMB_STORAGE_TOKEN_RESPONSE_NAME);\r\n\t\tif (tokenResponseJson) {\r\n\t\t\tconst response = new TokenResponse(JSON.parse(tokenResponseJson));\r\n\t\t\tthis.#tokenResponse.setValue(response);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method will check if there is a new authorization to be made and complete it if there is.\r\n\t * This method will be called on initialization to check if there is a new authorization to be made.\r\n\t * It is useful if there is a ?code query string parameter in the URL from the server or if the auth flow\r\n\t * saved the state in local storage before redirecting the user to the login page.\r\n\t */\r\n\tcompleteAuthorizationIfPossible() {\r\n\t\treturn this.#authorizationHandler.completeAuthorizationRequestIfPossible();\r\n\t}\r\n\r\n\t/**\r\n\t * Make an authorization request to the server using the specified identity provider.\r\n\t * This method will redirect the user to the authorization endpoint of the server.\r\n\t * @param identityProvider The identity provider to use for the authorization request.\r\n\t * @param usernameHint (Optional) The username to use for the authorization request. It will be provided to the OpenID server as a hint.\r\n\t */\r\n\tmakeAuthorizationRequest(identityProvider: string, usernameHint?: string) {\r\n\t\tconst extras: StringMap = { prompt: 'consent', access_type: 'offline' };\r\n\r\n\t\t// If the identity provider is not 'Umbraco', we will add it to the extras.\r\n\t\tif (identityProvider !== 'Umbraco') {\r\n\t\t\textras['identity_provider'] = identityProvider;\r\n\t\t}\r\n\r\n\t\t// If there is a username hint, we will add it to the extras.\r\n\t\tif (usernameHint) {\r\n\t\t\textras['login_hint'] = usernameHint;\r\n\t\t}\r\n\r\n\t\t// create a request\r\n\t\tconst request = new AuthorizationRequest(\r\n\t\t\t{\r\n\t\t\t\tclient_id: this.#clientId,\r\n\t\t\t\tredirect_uri: this.#redirectUri,\r\n\t\t\t\tscope: this.#scope,\r\n\t\t\t\tresponse_type: AuthorizationRequest.RESPONSE_TYPE_CODE,\r\n\t\t\t\tstate: undefined,\r\n\t\t\t\textras: extras,\r\n\t\t\t},\r\n\t\t\tundefined,\r\n\t\t\ttrue,\r\n\t\t);\r\n\r\n\t\treturn this.#authorizationHandler.performAuthorizationRequest(this.#configuration, request);\r\n\t}\r\n\r\n\t/**\r\n\t * This method will check if the user is logged in by validating if there is a token stored.\r\n\t * If no token is stored, it will return false.\r\n\t * @returns true if the user is logged in, false otherwise.\r\n\t */\r\n\tisAuthorized(): boolean {\r\n\t\treturn !!this.#tokenResponse.getValue();\r\n\t}\r\n\r\n\t/**\r\n\t * Forget all cached token state\r\n\t */\r\n\tasync clearTokenStorage() {\r\n\t\tawait this.#storageBackend.removeItem(UMB_STORAGE_TOKEN_RESPONSE_NAME);\r\n\r\n\t\t// clear the internal state\r\n\t\tthis.#tokenResponse.setValue(undefined);\r\n\r\n\t\t// Also cleanup any OAuth/PKCE artifacts that may still be in localStorage\r\n\t\t// This is a defense-in-depth measure during logout\r\n\t\tawait this.#authorizationHandler.cleanupStaleAuthorizationData();\r\n\t}\r\n\r\n\t/**\r\n\t * This method will sign the user out of the application.\r\n\t */\r\n\tasync signOut() {\r\n\t\tconst signOutPromises: Promise<unknown>[] = [];\r\n\r\n\t\t// revoke the access token if it exists\r\n\t\tif (this.#tokenResponse.value) {\r\n\t\t\tconst tokenRevokeRequest = new RevokeTokenRequest({\r\n\t\t\t\ttoken: this.#tokenResponse.value.accessToken,\r\n\t\t\t\tclient_id: this.#clientId,\r\n\t\t\t\ttoken_type_hint: 'access_token',\r\n\t\t\t});\r\n\r\n\t\t\tsignOutPromises.push(this.#tokenHandler.performRevokeTokenRequest(this.#configuration, tokenRevokeRequest));\r\n\r\n\t\t\t// revoke the refresh token if it exists\r\n\t\t\tif (this.#tokenResponse.value.refreshToken) {\r\n\t\t\t\tconst refreshTokenRevokeRequest = new RevokeTokenRequest({\r\n\t\t\t\t\ttoken: this.#tokenResponse.value.refreshToken,\r\n\t\t\t\t\tclient_id: this.#clientId,\r\n\t\t\t\t\ttoken_type_hint: 'refresh_token',\r\n\t\t\t\t});\r\n\r\n\t\t\t\tsignOutPromises.push(\r\n\t\t\t\t\tthis.#tokenHandler.performRevokeTokenRequest(this.#configuration, refreshTokenRevokeRequest),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// clear the internal token state\r\n\t\tsignOutPromises.push(this.clearTokenStorage());\r\n\r\n\t\t// wait for all promises to settle before continuing\r\n\t\tawait Promise.allSettled(signOutPromises);\r\n\r\n\t\t// clear the session on the server as well\r\n\t\t// this will redirect the user to the end session endpoint of the server\r\n\t\t// which will redirect the user back to the client\r\n\t\t// and the client will then try and log in again (if the user is not logged in)\r\n\t\t// which will redirect the user to the login page\r\n\t\tconst postLogoutRedirectUri = new URL(this.#postLogoutRedirectUri, window.origin);\r\n\t\tconst endSessionEndpoint = this.#configuration.endSessionEndpoint;\r\n\t\tif (!endSessionEndpoint) {\r\n\t\t\tlocation.href = postLogoutRedirectUri.href;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst postLogoutLocation = new URL(endSessionEndpoint, this.#redirectUri);\r\n\t\tpostLogoutLocation.searchParams.set('post_logout_redirect_uri', postLogoutRedirectUri.href);\r\n\t\tlocation.href = postLogoutLocation.href;\r\n\t}\r\n\r\n\t/**\r\n\t * This method will check if the token needs to be refreshed and if so, it will refresh it and return the new access token.\r\n\t * If the token does not need to be refreshed, it will return the current access token.\r\n\t * @returns {Promise<string>} The access token for the user.\r\n\t */\r\n\tasync performWithFreshTokens(): Promise<string> {\r\n\t\t// if the access token is valid, return it\r\n\t\tif (this.#tokenResponse.value?.isValid()) {\r\n\t\t\treturn Promise.resolve(this.#tokenResponse.value.accessToken);\r\n\t\t}\r\n\r\n\t\t// if the access token is not valid, try to refresh it\r\n\t\tconst success = await this.makeRefreshTokenRequest();\r\n\t\tconst newToken = this.#tokenResponse.value?.accessToken ?? '';\r\n\r\n\t\tif (!success) {\r\n\t\t\t// if the refresh token request failed, we need to clear the token state\r\n\t\t\tthis.clearTokenStorage();\r\n\t\t}\r\n\r\n\t\t// if the refresh token request was successful, return the new access token\r\n\t\treturn Promise.resolve(newToken);\r\n\t}\r\n\r\n\t/**\r\n\t * This method will link the current user to the specified provider by redirecting the user to the link endpoint.\r\n\t * @param provider The provider to link to.\r\n\t */\r\n\tasync linkLogin(provider: string): Promise<void> {\r\n\t\tconst linkKey = await this.#makeLinkTokenRequest(provider);\r\n\r\n\t\tconst form = document.createElement('form');\r\n\t\tform.method = 'POST';\r\n\t\tform.action = this.#link_endpoint;\r\n\t\tform.style.display = 'none';\r\n\r\n\t\tconst providerInput = document.createElement('input');\r\n\t\tproviderInput.name = 'provider';\r\n\t\tproviderInput.value = provider;\r\n\t\tform.appendChild(providerInput);\r\n\r\n\t\tconst linkKeyInput = document.createElement('input');\r\n\t\tlinkKeyInput.name = 'linkKey';\r\n\t\tlinkKeyInput.value = linkKey;\r\n\t\tform.appendChild(linkKeyInput);\r\n\r\n\t\tdocument.body.appendChild(form);\r\n\t\tform.submit();\r\n\t}\r\n\r\n\t/**\r\n\t * This method will unlink the current user from the specified provider.\r\n\t * @param loginProvider\r\n\t * @param providerKey\r\n\t */\r\n\tasync unlinkLogin(loginProvider: string, providerKey: string): Promise<boolean> {\r\n\t\tconst token = await this.performWithFreshTokens();\r\n\t\tconst request = new Request(this.#unlink_endpoint, {\r\n\t\t\tmethod: 'POST',\r\n\t\t\tcredentials: 'include',\r\n\t\t\theaders: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },\r\n\t\t\tbody: JSON.stringify({ loginProvider, providerKey }),\r\n\t\t});\r\n\r\n\t\tconst result = await fetch(request);\r\n\r\n\t\tif (!result.ok) {\r\n\t\t\tconst error = await result.json();\r\n\t\t\tthrow error;\r\n\t\t}\r\n\r\n\t\tawait this.signOut();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Save the current token response to local storage.\r\n\t */\r\n\tasync #saveTokenState() {\r\n\t\tawait this.#storageBackend.removeItem(UMB_STORAGE_TOKEN_RESPONSE_NAME);\r\n\t\tif (this.#tokenResponse.value) {\r\n\t\t\tawait this.#storageBackend.setItem(\r\n\t\t\t\tUMB_STORAGE_TOKEN_RESPONSE_NAME,\r\n\t\t\t\tJSON.stringify(this.#tokenResponse.value.toJson()),\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method will make a token request to the server using the authorization code.\r\n\t * @param code\r\n\t * @param codeVerifier\r\n\t */\r\n\tasync #makeTokenRequest(code: string, codeVerifier: string | undefined): Promise<void> {\r\n\t\tconst extras: StringMap = {};\r\n\r\n\t\tif (codeVerifier) {\r\n\t\t\textras.code_verifier = codeVerifier;\r\n\t\t}\r\n\r\n\t\t// use the code to make the token request.\r\n\t\tconst request = new TokenRequest({\r\n\t\t\tclient_id: this.#clientId,\r\n\t\t\tredirect_uri: this.#redirectUri,\r\n\t\t\tgrant_type: GRANT_TYPE_AUTHORIZATION_CODE,\r\n\t\t\tcode: code,\r\n\t\t\trefresh_token: undefined,\r\n\t\t\textras: extras,\r\n\t\t});\r\n\r\n\t\tawait this.#performTokenRequest(request);\r\n\t}\r\n\r\n\tasync makeRefreshTokenRequest(): Promise<boolean> {\r\n\t\tif (!this.#tokenResponse.value?.refreshToken) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst request = new TokenRequest({\r\n\t\t\tclient_id: this.#clientId,\r\n\t\t\tredirect_uri: this.#redirectUri,\r\n\t\t\tgrant_type: GRANT_TYPE_REFRESH_TOKEN,\r\n\t\t\tcode: undefined,\r\n\t\t\trefresh_token: this.#tokenResponse.value.refreshToken,\r\n\t\t\textras: undefined,\r\n\t\t});\r\n\r\n\t\treturn this.#performTokenRequest(request);\r\n\t}\r\n\r\n\t/**\r\n\t * This method will make a token request to the server using the refresh token.\r\n\t * If the request fails, it will sign the user out (clear the token state).\r\n\t * @param request\r\n\t */\r\n\tasync #performTokenRequest(request: TokenRequest): Promise<boolean> {\r\n\t\ttry {\r\n\t\t\tconst tokenResponse = await this.#tokenHandler.performTokenRequest(this.#configuration, request);\r\n\t\t\tthis.#tokenResponse.setValue(tokenResponse);\r\n\t\t\tawait this.#saveTokenState();\r\n\t\t\treturn true;\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error('Token request error', error);\r\n\t\t\tthis.clearTokenStorage();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tasync #makeLinkTokenRequest(provider: string) {\r\n\t\tconst token = await this.performWithFreshTokens();\r\n\r\n\t\tconst request = await fetch(`${this.#link_key_endpoint}?provider=${provider}`, {\r\n\t\t\tcredentials: 'include',\r\n\t\t\theaders: {\r\n\t\t\t\tAuthorization: `Bearer ${token}`,\r\n\t\t\t\t'Content-Type': 'application/json',\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\tif (!request.ok) {\r\n\t\t\tthrow new Error('Failed to link login');\r\n\t\t}\r\n\r\n\t\treturn request.json();\r\n\t}\r\n}\r\n","import { UmbModalToken } from '../../modal/token/modal-token.js';\r\n\r\nexport type UmbModalAuthTimeoutConfig = {\r\n\tremainingTimeInSeconds: number;\r\n\tonLogout: () => void;\r\n\tonContinue: () => void;\r\n};\r\n\r\nexport const UMB_MODAL_AUTH_TIMEOUT = new UmbModalToken<UmbModalAuthTimeoutConfig, never>('Umb.Modal.AuthTimeout', {\r\n\tmodal: {\r\n\t\ttype: 'dialog',\r\n\t},\r\n});\r\n","import type { UmbAuthFlow } from '../auth-flow.js';\r\nimport type { UmbAuthContext } from '../auth.context.js';\r\nimport { UMB_MODAL_AUTH_TIMEOUT } from '../modals/umb-auth-timeout-modal.token.js';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport { UserService } from '@umbraco-cms/backoffice/external/backend-api';\r\n\r\nexport class UmbAuthSessionTimeoutController extends UmbControllerBase {\r\n\t#tokenCheckWorker?: SharedWorker;\r\n\t#host: UmbAuthContext;\r\n\t#keepUserLoggedIn = false;\r\n\t#hasCheckedKeepUserLoggedIn = false;\r\n\r\n\tconstructor(host: UmbAuthContext, authFlow: UmbAuthFlow) {\r\n\t\tsuper(host, 'UmbAuthSessionTimeoutController');\r\n\r\n\t\tthis.#host = host;\r\n\r\n\t\tthis.#tokenCheckWorker = new SharedWorker(new URL('../workers/token-check.worker.js', import.meta.url), {\r\n\t\t\tname: 'TokenCheckWorker',\r\n\t\t\ttype: 'module',\r\n\t\t});\r\n\r\n\t\t// Ensure the worker is ready to receive messages\r\n\t\tthis.#tokenCheckWorker.port.start();\r\n\r\n\t\t// Listen for messages from the token check worker\r\n\t\tthis.#tokenCheckWorker.port.onmessage = async (event) => {\r\n\t\t\t// If the user has chosen to stay logged in, we ignore the logout command and instead request a new token\r\n\t\t\tif (this.#keepUserLoggedIn) {\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t'[Auth Context] User chose to stay logged in, attempting to validate token instead of logging out.',\r\n\t\t\t\t);\r\n\t\t\t\tawait this.#tryValidateToken();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (event.data?.command === 'logout') {\r\n\t\t\t\t// If the worker signals a logout, we clear the token storage and set the user as unauthorized\r\n\t\t\t\thost.timeOut();\r\n\t\t\t} else if (event.data?.command === 'refreshToken') {\r\n\t\t\t\t// If the worker signals a token refresh, we let the user decide whether to continue or logout\r\n\t\t\t\tthis.#openTimeoutModal(event.data.secondsUntilLogout);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Initialize the token check worker with the current token response\r\n\t\tthis.observe(\r\n\t\t\tauthFlow.token$,\r\n\t\t\t(tokenResponse) => {\r\n\t\t\t\t// Inform the token check worker about the new token response\r\n\t\t\t\tconsole.log('[Auth Context] Informing token check worker about new token response.');\r\n\t\t\t\t// Post the new\r\n\t\t\t\tthis.#tokenCheckWorker?.port.postMessage({\r\n\t\t\t\t\tcommand: 'init',\r\n\t\t\t\t\ttokenResponse,\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\t'_authFlowAuthorizationSignal',\r\n\t\t);\r\n\r\n\t\t// Listen for the timeout signal to stop the token check worker\r\n\t\tthis.observe(\r\n\t\t\thost.timeoutSignal,\r\n\t\t\tasync () => {\r\n\t\t\t\t// Stop the token check worker when the user has timed out\r\n\t\t\t\tthis.#tokenCheckWorker?.port.postMessage({\r\n\t\t\t\t\tcommand: 'init',\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Close the modal if it is open\r\n\t\t\t\tawait this.#closeTimeoutModal();\r\n\t\t\t},\r\n\t\t\t'_authFlowTimeoutSignal',\r\n\t\t);\r\n\r\n\t\tthis.observe(\r\n\t\t\thost.isAuthorized,\r\n\t\t\t(isAuthorized) => {\r\n\t\t\t\tif (isAuthorized) {\r\n\t\t\t\t\tthis.#observeKeepUserLoggedIn();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t'_authFlowIsAuthorizedSignal',\r\n\t\t);\r\n\t}\r\n\r\n\toverride destroy(): void {\r\n\t\tsuper.destroy();\r\n\t\tthis.#tokenCheckWorker?.port.close();\r\n\t\tthis.#tokenCheckWorker = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Observe the user's preference for staying logged in\r\n\t * and update the internal state accordingly.\r\n\t * This method fetches the current user configuration from the server to find the value.\r\n\t * // TODO: We cannot observe the config store directly here yet, as it would create a circular dependency, so maybe we need to move the config option somewhere else?\r\n\t */\r\n\tasync #observeKeepUserLoggedIn() {\r\n\t\tif (this.#hasCheckedKeepUserLoggedIn) return;\r\n\t\tthis.#hasCheckedKeepUserLoggedIn = true;\r\n\t\t// eslint-disable-next-line local-rules/no-direct-api-import\r\n\t\tconst { data } = await UserService.getUserCurrentConfiguration();\r\n\t\tthis.#keepUserLoggedIn = data?.keepUserLoggedIn ?? false;\r\n\t}\r\n\r\n\tasync #closeTimeoutModal() {\r\n\t\tconst contextToken = (await import('@umbraco-cms/backoffice/modal')).UMB_MODAL_MANAGER_CONTEXT;\r\n\t\tconst modalManager = await this.getContext(contextToken);\r\n\t\tmodalManager?.close('auth-timeout');\r\n\t}\r\n\r\n\tasync #openTimeoutModal(remainingTimeInSeconds: number) {\r\n\t\tconst contextToken = (await import('@umbraco-cms/backoffice/modal')).UMB_MODAL_MANAGER_CONTEXT;\r\n\t\tconst modalManager = await this.getContext(contextToken);\r\n\t\tmodalManager\r\n\t\t\t?.open(this, UMB_MODAL_AUTH_TIMEOUT, {\r\n\t\t\t\tmodal: {\r\n\t\t\t\t\tkey: 'auth-timeout',\r\n\t\t\t\t},\r\n\t\t\t\tdata: {\r\n\t\t\t\t\tremainingTimeInSeconds,\r\n\t\t\t\t\tonLogout: () => {\r\n\t\t\t\t\t\tthis.#host.signOut();\r\n\t\t\t\t\t},\r\n\t\t\t\t\tonContinue: () => {\r\n\t\t\t\t\t\t// If the user chooses to stay logged in, we validate the token\r\n\t\t\t\t\t\tthis.#tryValidateToken();\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t})\r\n\t\t\t.onSubmit()\r\n\t\t\t.catch(() => {\r\n\t\t\t\t// If the modal is forced closed or an error occurs, we handle it gracefully\r\n\t\t\t\tthis.#tryValidateToken();\r\n\t\t\t});\r\n\t}\r\n\r\n\tasync #tryValidateToken() {\r\n\t\ttry {\r\n\t\t\tawait this.#host.validateToken();\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error('[Auth Context] Error validating token:', error);\r\n\t\t\t// If the token validation fails, we clear the token storage and set the user as unauthorized\r\n\t\t\tthis.#host.timeOut();\r\n\t\t}\r\n\t}\r\n}\r\n","import { UmbAuthFlow } from './auth-flow.js';\r\nimport { UMB_AUTH_CONTEXT } from './auth.context.token.js';\r\nimport { UmbAuthSessionTimeoutController } from './controllers/auth-session-timeout.controller.js';\r\nimport type { UmbOpenApiConfiguration } from './models/openApiConfiguration.js';\r\nimport type { ManifestAuthProvider } from './auth-provider.extension.js';\r\nimport { UMB_STORAGE_TOKEN_RESPONSE_NAME } from './constants.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { UmbContextBase } from '@umbraco-cms/backoffice/class-api';\r\nimport { UmbBooleanState } from '@umbraco-cms/backoffice/observable-api';\r\nimport {\r\n\tReplaySubject,\r\n\tSubject,\r\n\tfirstValueFrom,\r\n\tswitchMap,\r\n\tdistinctUntilChanged,\r\n\tthrottleTime,\r\n\tauditTime,\r\n} from '@umbraco-cms/backoffice/external/rxjs';\r\nimport type { Observable } from '@umbraco-cms/backoffice/external/rxjs';\r\nimport type { UmbBackofficeExtensionRegistry } from '@umbraco-cms/backoffice/extension-registry';\r\nimport { umbHttpClient } from '@umbraco-cms/backoffice/http-client';\r\nimport { isTestEnvironment } from '@umbraco-cms/backoffice/utils';\r\n\r\nexport class UmbAuthContext extends UmbContextBase {\r\n\t#isAuthorized = new UmbBooleanState<boolean>(false);\r\n\t// Timeout is different from `isAuthorized` because it can occur repeatedly\r\n\t#isTimeout = new Subject<void>();\r\n\t#isInitialized = new ReplaySubject<void>(1);\r\n\t#isBypassed;\r\n\t#serverUrl;\r\n\t#backofficePath;\r\n\t#authFlow;\r\n\r\n\t#authWindowProxy?: WindowProxy | null;\r\n\t#previousAuthUrl?: string;\r\n\r\n\t/**\r\n\t * Observable that emits true when the auth context is initialized.\r\n\t * @remark It will only emit once and then complete itself.\r\n\t */\r\n\treadonly isInitialized = this.#isInitialized.asObservable();\r\n\r\n\t/**\r\n\t * Observable that emits true if the user is authorized, otherwise false.\r\n\t * @remark It will only emit when the authorization state changes.\r\n\t */\r\n\treadonly isAuthorized = this.#isAuthorized.asObservable().pipe(distinctUntilChanged());\r\n\r\n\t/**\r\n\t * Observable that acts as a signal and emits when the user has timed out, i.e. the token has expired.\r\n\t * This can be used to show a timeout message to the user.\r\n\t * @remark It will emit once per second, so it can be used to trigger UI updates or other actions when the user has timed out.\r\n\t */\r\n\treadonly timeoutSignal = this.#isTimeout.asObservable().pipe(\r\n\t\t// Audit the timeout signal to ensure that it waits for 1s before allowing another emission, which prevents rapid firing of the signal.\r\n\t\t// This is useful to prevent the UI from being flooded with timeout events.\r\n\t\tauditTime(1000),\r\n\t);\r\n\r\n\t/**\r\n\t * Observable that acts as a signal for when the authorization state changes.\r\n\t * @remark It will emit once per second, so it can be used to trigger UI updates or other actions when the authorization state changes.\r\n\t * @returns {Subject<void>} An observable that emits when the authorization state changes.\r\n\t */\r\n\tget authorizationSignal(): Observable<void> {\r\n\t\treturn this.#authFlow.authorizationSignal.asObservable().pipe(\r\n\t\t\t// Throttle the signal to ensure that it emits once, then waits for 1s before allowing another emission.\r\n\t\t\tthrottleTime(1000),\r\n\t\t);\r\n\t}\r\n\r\n\tconstructor(host: UmbControllerHost, serverUrl: string, backofficePath: string, isBypassed: boolean) {\r\n\t\tsuper(host, UMB_AUTH_CONTEXT);\r\n\t\tthis.#isBypassed = isBypassed;\r\n\t\tthis.#serverUrl = serverUrl;\r\n\t\tthis.#backofficePath = backofficePath;\r\n\r\n\t\tthis.#authFlow = new UmbAuthFlow(serverUrl, this.getRedirectUrl(), this.getPostLogoutRedirectUrl());\r\n\r\n\t\t// Observe the authorization signal and close the auth window\r\n\t\tthis.observe(\r\n\t\t\tthis.authorizationSignal,\r\n\t\t\t() => {\r\n\t\t\t\t// Update the authorization state\r\n\t\t\t\tthis.getIsAuthorized();\r\n\t\t\t},\r\n\t\t\t'_authFlowAuthorizationSignal',\r\n\t\t);\r\n\r\n\t\t// Observe changes to local storage and update the authorization state\r\n\t\t// This establishes the tab-to-tab communication\r\n\t\twindow.addEventListener('storage', this.#onStorageEvent.bind(this));\r\n\r\n\t\tif (!isTestEnvironment()) {\r\n\t\t\t// Start the session timeout controller\r\n\t\t\tnew UmbAuthSessionTimeoutController(this, this.#authFlow);\r\n\t\t}\r\n\t}\r\n\r\n\toverride destroy(): void {\r\n\t\tsuper.destroy();\r\n\t\twindow.removeEventListener('storage', this.#onStorageEvent.bind(this));\r\n\t}\r\n\r\n\tasync #onStorageEvent(evt: StorageEvent) {\r\n\t\tif (evt.key === UMB_STORAGE_TOKEN_RESPONSE_NAME) {\r\n\t\t\t// Close any open auth windows\r\n\t\t\tthis.#authWindowProxy?.close();\r\n\t\t\t// Refresh the local storage state into memory\r\n\t\t\tawait this.setInitialState();\r\n\t\t\t// Let any auth listeners (such as the auth modal) know that the auth state has changed\r\n\t\t\tthis.#authFlow.authorizationSignal.next();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Initiates the login flow.\r\n\t * @param identityProvider The provider to use for login. Default is 'Umbraco'.\r\n\t * @param redirect If true, the user will be redirected to the login page.\r\n\t * @param usernameHint The username hint to use for login.\r\n\t * @param manifest The manifest for the registered provider.\r\n\t */\r\n\tasync makeAuthorizationRequest(\r\n\t\tidentityProvider = 'Umbraco',\r\n\t\tredirect?: boolean,\r\n\t\tusernameHint?: string,\r\n\t\tmanifest?: ManifestAuthProvider,\r\n\t) {\r\n\t\tconst redirectUrl = await this.#authFlow.makeAuthorizationRequest(identityProvider, usernameHint);\r\n\t\tif (redirect) {\r\n\t\t\tlocation.href = redirectUrl;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst popupTarget = manifest?.meta?.behavior?.popupTarget ?? 'umbracoAuthPopup';\r\n\t\tconst popupFeatures =\r\n\t\t\tmanifest?.meta?.behavior?.popupFeatures ??\r\n\t\t\t'width=600,height=600,menubar=no,location=no,resizable=yes,scrollbars=yes,status=no,toolbar=no';\r\n\r\n\t\tif (!this.#authWindowProxy || this.#authWindowProxy.closed) {\r\n\t\t\tthis.#authWindowProxy = window.open(redirectUrl, popupTarget, popupFeatures);\r\n\t\t} else if (this.#previousAuthUrl !== redirectUrl) {\r\n\t\t\tthis.#authWindowProxy = window.open(redirectUrl, popupTarget);\r\n\t\t\tthis.#authWindowProxy?.focus();\r\n\t\t}\r\n\r\n\t\tthis.#previousAuthUrl = redirectUrl;\r\n\r\n\t\treturn firstValueFrom(this.authorizationSignal);\r\n\t}\r\n\r\n\t/**\r\n\t * Completes the login flow.\r\n\t */\r\n\tcompleteAuthorizationRequest() {\r\n\t\treturn this.#authFlow.completeAuthorizationIfPossible();\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the user is authorized. If Authorization is bypassed, the user is always authorized.\r\n\t * @returns True if the user is authorized, otherwise false.\r\n\t */\r\n\tgetIsAuthorized() {\r\n\t\tif (this.#isBypassed) {\r\n\t\t\tthis.#isAuthorized.setValue(true);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tconst isAuthorized = this.#authFlow.isAuthorized();\r\n\t\t\tthis.#isAuthorized.setValue(isAuthorized);\r\n\t\t\treturn isAuthorized;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the initial state of the auth flow.\r\n\t * @returns {Promise<void>}\r\n\t */\r\n\tsetInitialState(): Promise<void> {\r\n\t\treturn this.#authFlow.setInitialState();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the latest token from the Management API.\r\n\t * If the token is expired, it will be refreshed.\r\n\t *\r\n\t * NB! The user may experience being redirected to the login screen if the token is expired.\r\n\t * @example <caption>Using the latest token</caption>\r\n\t * ```js\r\n\t *   const token = await authContext.getLatestToken();\r\n\t *   const result = await fetch('https://my-api.com', { headers: { Authorization: `Bearer ${token}` } });\r\n\t * ```\r\n\t * @memberof UmbAuthContext\r\n\t * @returns The latest token from the Management API\r\n\t */\r\n\tgetLatestToken(): Promise<string> {\r\n\t\treturn this.#authFlow.performWithFreshTokens();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the token against the server and returns true if the token is valid.\r\n\t * @memberof UmbAuthContext\r\n\t * @returns True if the token is valid, otherwise false\r\n\t */\r\n\tasync validateToken(): Promise<boolean> {\r\n\t\treturn this.#isBypassed || this.#authFlow.makeRefreshTokenRequest();\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the token storage.\r\n\t * @memberof UmbAuthContext\r\n\t */\r\n\tclearTokenStorage() {\r\n\t\treturn this.#authFlow.clearTokenStorage();\r\n\t}\r\n\r\n\t/**\r\n\t * Handles the case where the user has timed out, i.e. the token has expired.\r\n\t * This will clear the token storage and set the user as unauthorized.\r\n\t * @memberof UmbAuthContext\r\n\t */\r\n\ttimeOut() {\r\n\t\tthis.#isAuthorized.setValue(false);\r\n\t\tthis.#isTimeout.next();\r\n\t}\r\n\r\n\t/**\r\n\t * Signs the user out by removing any tokens from the browser.\r\n\t * @memberof UmbAuthContext\r\n\t */\r\n\tsignOut(): Promise<void> {\r\n\t\treturn this.#authFlow.signOut();\r\n\t}\r\n\r\n\t/**\r\n\t * Get the server url to the Management API.\r\n\t * @memberof UmbAuthContext\r\n\t * @example <caption>Using the server url</caption>\r\n\t * ```js\r\n\t * \tconst serverUrl = authContext.getServerUrl();\r\n\t * \tOpenAPI.BASE = serverUrl;\r\n\t * ```\r\n\t * @example <caption></caption>\r\n\t * ```js\r\n\t * \tconst serverUrl = authContext.getServerUrl();\r\n\t * \tconst token = await authContext.getLatestToken();\r\n\t * \tconst result = await fetch(`${serverUrl}/umbraco/management/api/v1/my-resource`, { headers: { Authorization: `Bearer ${token}` } });\r\n\t * ```\r\n\t * @returns The server url to the Management API\r\n\t */\r\n\tgetServerUrl() {\r\n\t\treturn this.#serverUrl;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the default OpenAPI configuration, which is set up to communicate with the Management API.\r\n\t * @remark This is useful if you want to communicate with your own resources generated by the [@hey-api/openapi-ts](https://github.com/hey-api/openapi-ts) library.\r\n\t * @memberof UmbAuthContext\r\n\t * @example <caption>Using the default OpenAPI configuration</caption>\r\n\t * ```js\r\n\t * const defaultOpenApi = authContext.getOpenApiConfiguration();\r\n\t * client.setConfig({\r\n\t *   base: defaultOpenApi.base,\r\n\t *   auth: defaultOpenApi.token,\r\n\t * });\r\n\t * ```\r\n\t * @returns {UmbOpenApiConfiguration} The default OpenAPI configuration\r\n\t */\r\n\tgetOpenApiConfiguration(): UmbOpenApiConfiguration {\r\n\t\tconst config = umbHttpClient.getConfig();\r\n\t\treturn {\r\n\t\t\tbase: config.baseUrl,\r\n\t\t\tcredentials: config.credentials,\r\n\t\t\ttoken: () => this.getLatestToken(),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the auth context as initialized, which means that the auth context is ready to be used.\r\n\t * @remark This is used to let the app context know that the core module is ready, which means that the core auth providers are available.\r\n\t */\r\n\tsetInitialized() {\r\n\t\tthis.#isInitialized.next();\r\n\t\tthis.#isInitialized.complete();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets all registered auth providers.\r\n\t * @param extensionsRegistry\r\n\t */\r\n\tgetAuthProviders(extensionsRegistry: UmbBackofficeExtensionRegistry) {\r\n\t\treturn this.#isInitialized.pipe(\r\n\t\t\tswitchMap(() => extensionsRegistry.byType<'authProvider', ManifestAuthProvider>('authProvider')),\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the authorized redirect url.\r\n\t * @returns The redirect url, which is the backoffice path.\r\n\t */\r\n\tgetRedirectUrl() {\r\n\t\treturn `${window.location.origin}${this.#backofficePath}${this.#backofficePath.endsWith('/') ? '' : '/'}oauth_complete`;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the post logout redirect url.\r\n\t * @returns The post logout redirect url, which is the backoffice path with the logout path appended.\r\n\t */\r\n\tgetPostLogoutRedirectUrl() {\r\n\t\treturn `${window.location.origin}${this.#backofficePath}${this.#backofficePath.endsWith('/') ? '' : '/'}logout`;\r\n\t}\r\n\r\n\t/**\r\n\t * @param provider\r\n\t * @see UmbAuthFlow#linkLogin\r\n\t */\r\n\tlinkLogin(provider: string) {\r\n\t\treturn this.#authFlow.linkLogin(provider);\r\n\t}\r\n\r\n\t/**\r\n\t * @param providerName\r\n\t * @param providerKey\r\n\t * @see UmbAuthFlow#unlinkLogin\r\n\t */\r\n\tunlinkLogin(providerName: string, providerKey: string) {\r\n\t\treturn this.#authFlow.unlinkLogin(providerName, providerKey);\r\n\t}\r\n}\r\n","import { UmbModalToken } from '../../modal/token/index.js';\r\nimport type { UmbUserLoginState } from '../types.js';\r\n\r\nexport type UmbModalAppAuthConfig = {\r\n\tuserLoginState: UmbUserLoginState;\r\n};\r\n\r\nexport type UmbModalAppAuthValue = {\r\n\t/**\r\n\t * An indicator of whether the authentication was successful.\r\n\t * @required\r\n\t */\r\n\tsuccess?: boolean;\r\n};\r\n\r\nexport const UMB_MODAL_APP_AUTH = new UmbModalToken<UmbModalAppAuthConfig, UmbModalAppAuthValue>('Umb.Modal.AppAuth', {\r\n\tmodal: {\r\n\t\ttype: 'dialog',\r\n\t},\r\n});\r\n"],"names":["_UmbAuthProviderDefaultElement_instances","label_get","UmbAuthProviderDefaultElement","UmbLitElement","__privateAdd","html","__privateGet","nothing","label","labelLocalized","UmbTextStyles","css","__decorateClass","property","customElement","UMB_STORAGE_TOKEN_RESPONSE_NAME","requestor","FetchRequestor","UmbNoHashQueryStringUtils","BasicQueryStringUtils","input","UmbAuthFlow","openIdConnectUrl","redirectUri","postLogoutRedirectUri","clientId","scope","#tokenResponse","UmbObjectState","Subject","#redirectUri","#postLogoutRedirectUri","#clientId","#scope","#configuration","AuthorizationServiceConfiguration","#link_endpoint","#link_key_endpoint","#unlink_endpoint","#notifier","AuthorizationNotifier","#tokenHandler","BaseTokenRequestHandler","#storageBackend","LocalStorageBackend","#authorizationHandler","RedirectRequestHandler","request","response","error","codeVerifier","#makeTokenRequest","#saveTokenState","tokenResponseJson","TokenResponse","identityProvider","usernameHint","extras","AuthorizationRequest","signOutPromises","tokenRevokeRequest","RevokeTokenRequest","refreshTokenRevokeRequest","endSessionEndpoint","postLogoutLocation","success","newToken","provider","linkKey","#makeLinkTokenRequest","form","providerInput","linkKeyInput","loginProvider","providerKey","token","result","code","TokenRequest","GRANT_TYPE_AUTHORIZATION_CODE","#performTokenRequest","GRANT_TYPE_REFRESH_TOKEN","tokenResponse","UMB_MODAL_AUTH_TIMEOUT","UmbModalToken","UmbAuthSessionTimeoutController","UmbControllerBase","#tokenCheckWorker","#host","#keepUserLoggedIn","#hasCheckedKeepUserLoggedIn","host","authFlow","event","#tryValidateToken","#openTimeoutModal","#closeTimeoutModal","isAuthorized","#observeKeepUserLoggedIn","data","UserService","contextToken","remainingTimeInSeconds","UmbAuthContext","UmbContextBase","serverUrl","backofficePath","isBypassed","UMB_AUTH_CONTEXT","#isAuthorized","UmbBooleanState","#isTimeout","#isInitialized","ReplaySubject","distinctUntilChanged","auditTime","#isBypassed","#serverUrl","#backofficePath","#authFlow","#onStorageEvent","isTestEnvironment","#authWindowProxy","#previousAuthUrl","throttleTime","evt","redirect","manifest","redirectUrl","popupTarget","popupFeatures","firstValueFrom","config","umbHttpClient","extensionsRegistry","switchMap","providerName","UMB_MODAL_APP_AUTH"],"mappings":"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"}