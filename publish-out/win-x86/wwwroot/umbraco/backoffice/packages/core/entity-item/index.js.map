{"version":3,"file":"index.js","sources":["../../../../src/packages/core/entity-item/item-data-api-get-request-controller/item-data-api-get-request.controller.ts"],"sourcesContent":["import type { UmbItemDataApiGetRequestControllerArgs } from './types.js';\r\nimport {\r\n\tbatchTryExecute,\r\n\ttryExecute,\r\n\tUmbError,\r\n\ttype UmbApiError,\r\n\ttype UmbCancelError,\r\n\ttype UmbDataApiResponse,\r\n} from '@umbraco-cms/backoffice/resources';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { batchArray } from '@umbraco-cms/backoffice/utils';\r\nimport { umbPeekError } from '@umbraco-cms/backoffice/notification';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\n\r\nexport class UmbItemDataApiGetRequestController<\r\n\tResponseModelType extends UmbDataApiResponse,\r\n> extends UmbControllerBase {\r\n\t#apiCallback: (args: { uniques: Array<string> }) => Promise<ResponseModelType>;\r\n\t#uniques: Array<string>;\r\n\t#batchSize: number = 40;\r\n\r\n\tconstructor(host: UmbControllerHost, args: UmbItemDataApiGetRequestControllerArgs<ResponseModelType>) {\r\n\t\tsuper(host);\r\n\t\tthis.#apiCallback = args.api;\r\n\t\tthis.#uniques = args.uniques;\r\n\t}\r\n\r\n\tasync request() {\r\n\t\tif (!this.#uniques) throw new Error('Uniques are missing');\r\n\r\n\t\tlet data: ResponseModelType['data'] | undefined;\r\n\t\tlet error: UmbError | UmbApiError | UmbCancelError | Error | undefined;\r\n\r\n\t\tif (this.#uniques.length > this.#batchSize) {\r\n\t\t\tconst chunks = batchArray<string>(this.#uniques, this.#batchSize);\r\n\t\t\tconst results = await batchTryExecute(this, chunks, (chunk) => this.#apiCallback({ uniques: chunk }));\r\n\r\n\t\t\tconst errors = results.filter((promiseResult) => promiseResult.status === 'rejected');\r\n\r\n\t\t\tif (errors.length > 0) {\r\n\t\t\t\terror = await this.#getAndHandleErrorResult(errors);\r\n\t\t\t}\r\n\r\n\t\t\tdata = results\r\n\t\t\t\t.filter((promiseResult) => promiseResult.status === 'fulfilled')\r\n\t\t\t\t.flatMap((promiseResult) => promiseResult.value.data);\r\n\t\t} else {\r\n\t\t\tconst result = await tryExecute(this, this.#apiCallback({ uniques: this.#uniques }));\r\n\t\t\tdata = result.data;\r\n\t\t\terror = result.error;\r\n\t\t}\r\n\r\n\t\treturn { data, error };\r\n\t}\r\n\r\n\tasync #getAndHandleErrorResult(errors: Array<PromiseRejectedResult>) {\r\n\t\t// TODO: We currently expect all the errors to be the same, but we should handle this better in the future.\r\n\t\tconst error = errors[0];\r\n\t\tawait umbPeekError(this, {\r\n\t\t\theadline: 'Error fetching items',\r\n\t\t\tmessage: 'An error occurred while fetching items.',\r\n\t\t});\r\n\r\n\t\treturn new UmbError(error.reason);\r\n\t}\r\n}\r\n"],"names":["UmbItemDataApiGetRequestController","UmbControllerBase","#apiCallback","#uniques","#batchSize","host","args","data","error","chunks","batchArray","results","batchTryExecute","chunk","errors","promiseResult","#getAndHandleErrorResult","result","tryExecute","umbPeekError","UmbError"],"mappings":";;;;;AAcO,MAAMA,UAEHC,EAAkB;AAAA,EAC3BC;AAAA,EACAC;AAAA,EACAC,KAAqB;AAAA,EAErB,YAAYC,GAAyBC,GAAiE;AACrG,UAAMD,CAAI,GACV,KAAKH,KAAeI,EAAK,KACzB,KAAKH,KAAWG,EAAK;AAAA,EACtB;AAAA,EAEA,MAAM,UAAU;AACf,QAAI,CAAC,KAAKH,GAAU,OAAM,IAAI,MAAM,qBAAqB;AAEzD,QAAII,GACAC;AAEJ,QAAI,KAAKL,GAAS,SAAS,KAAKC,IAAY;AAC3C,YAAMK,IAASC,EAAmB,KAAKP,IAAU,KAAKC,EAAU,GAC1DO,IAAU,MAAMC,EAAgB,MAAMH,GAAQ,CAACI,MAAU,KAAKX,GAAa,EAAE,SAASW,EAAA,CAAO,CAAC,GAE9FC,IAASH,EAAQ,OAAO,CAACI,MAAkBA,EAAc,WAAW,UAAU;AAEpF,MAAID,EAAO,SAAS,MACnBN,IAAQ,MAAM,KAAKQ,GAAyBF,CAAM,IAGnDP,IAAOI,EACL,OAAO,CAACI,MAAkBA,EAAc,WAAW,WAAW,EAC9D,QAAQ,CAACA,MAAkBA,EAAc,MAAM,IAAI;AAAA,IACtD,OAAO;AACN,YAAME,IAAS,MAAMC,EAAW,MAAM,KAAKhB,GAAa,EAAE,SAAS,KAAKC,GAAA,CAAU,CAAC;AACnF,MAAAI,IAAOU,EAAO,MACdT,IAAQS,EAAO;AAAA,IAChB;AAEA,WAAO,EAAE,MAAAV,GAAM,OAAAC,EAAA;AAAA,EAChB;AAAA,EAEA,MAAMQ,GAAyBF,GAAsC;AAEpE,UAAMN,IAAQM,EAAO,CAAC;AACtB,iBAAMK,EAAa,MAAM;AAAA,MACxB,UAAU;AAAA,MACV,SAAS;AAAA,IAAA,CACT,GAEM,IAAIC,EAASZ,EAAM,MAAM;AAAA,EACjC;AACD;"}